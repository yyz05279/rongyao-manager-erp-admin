# 重复物料全部更新功能实现说明

## 功能概述

在重复物料管理功能基础上，新增"全部更新"按钮，支持一键将某个物料的所有重复上传数量累加并更新到数据库。更新后按钮自动禁用，防止重复操作。

## 功能特性

### 1. 智能显示条件

- **显示条件**：仅在重复数据条数 > 1 时显示"全部更新"按钮
- **隐藏情况**：只有一条重复数据时不显示（此时只需使用单条更新即可）

### 2. 状态管理

使用 `Set` 数据结构记录已更新的物料 ID：

```typescript
const updatedItemIds = ref<Set<number>>(new Set()); // 已更新的物料ID集合
```

**优势**：

- 快速查找（O(1) 时间复杂度）
- 自动去重
- 内存高效

### 3. 按钮状态

#### 3.1 全部更新按钮

**位置**：建议操作组件的最右侧

**状态变化**：

- **初始状态**：`type="success"`，文本"全部更新"，可点击
- **更新后**：`type="success" disabled`，文本"已更新"，禁用状态，灰色显示

**代码实现**：

```vue
<el-button
  v-if="existedItemVo.duplicateItems.length > 1"
  type="success"
  size="small"
  :disabled="isItemUpdated(existedItemVo.existedItem.id)"
  @click="handleUpdateAllDuplicates(existedItemVo)"
  style="margin-left: 10px;"
>
  {{ isItemUpdated(existedItemVo.existedItem.id) ? '已更新' : '全部更新' }}
</el-button>
```

#### 3.2 单条更新按钮

**位置**：每条重复记录的操作列

**状态联动**：当该物料被"全部更新"后，所有单条更新按钮同步禁用

**代码实现**：

```vue
<el-button
  type="primary"
  size="small"
  :disabled="isItemUpdated(existedItemVo.existedItem.id)"
  @click="handleUpdateSingleItem(existedItemVo.existedItem, row)"
>
  {{ isItemUpdated(existedItemVo.existedItem.id) ? '已更新' : '更新' }}
</el-button>
```

## 核心方法实现

### 1. 状态检查方法

```typescript
/**
 * 检查物料是否已更新
 */
const isItemUpdated = (itemId: number): boolean => {
  return updatedItemIds.value.has(itemId);
};
```

**说明**：

- 使用 Set 的 `has()` 方法快速检查
- 返回 boolean 值用于按钮禁用判断

### 2. 全部更新方法

```typescript
/**
 * 全部更新（将所有重复数据的数量累加后更新）
 */
const handleUpdateAllDuplicates = async (existedItemVo: any) => {
  try {
    const accumulatedQuantity = calculateAccumulatedQuantity(existedItemVo);

    // 确认操作
    await ElMessageBox.confirm(
      `确定要将所有 ${existedItemVo.duplicateItems.length} 次重复上传的数量（共 ${calculateTotalDuplicateQuantity(existedItemVo.duplicateItems)} ${existedItemVo.existedItem.unit}）累加到现有数量吗？更新后将为 ${accumulatedQuantity} ${existedItemVo.existedItem.unit}`,
      '全部更新确认',
      {
        confirmButtonText: '确定',
        cancelButtonText: '取消',
        type: 'warning'
      }
    );

    // 构建更新数据
    const updateData = {
      id: existedItemVo.existedItem.id,
      materialName: existedItemVo.existedItem.materialName,
      specification: existedItemVo.existedItem.specification,
      quantity: accumulatedQuantity,
      unit: existedItemVo.existedItem.unit,
      version: existedItemVo.existedItem.version || 1
    };

    // 调用单个更新接口
    await updateMaterialItem(updateData);

    // 标记为已更新
    updatedItemIds.value.add(existedItemVo.existedItem.id);

    ElMessage.success('全部更新成功');

    // 刷新数据列表
    await initializeData();
  } catch (error: any) {
    if (error !== 'cancel') {
      console.error('全部更新失败:', error);
      ElMessage.error('全部更新失败：' + (error.message || '未知错误'));
    }
  }
};
```

**关键步骤**：

1. 计算累加后的总数量
2. 显示确认对话框（包含详细信息）
3. 调用单个更新接口（`updateMaterialItem`）
4. 将物料 ID 添加到已更新集合
5. 刷新数据列表

### 3. 单条更新方法增强

```typescript
/**
 * 更新单个物料明细
 */
const handleUpdateSingleItem = async (existedItem: any, duplicateItem: any) => {
  try {
    // 确认操作
    await ElMessageBox.confirm(
      `确定要将数量 ${duplicateItem.quantity} ${duplicateItem.unit} 累加到现有数量吗？更新后将为 ${existedItem.quantity + duplicateItem.quantity} ${existedItem.unit}`,
      '更新确认',
      {
        confirmButtonText: '确定',
        cancelButtonText: '取消',
        type: 'info'
      }
    );

    // 构建更新数据
    const updateData = {
      id: existedItem.id,
      materialName: existedItem.materialName,
      specification: existedItem.specification,
      quantity: existedItem.quantity + duplicateItem.quantity,
      unit: existedItem.unit,
      version: existedItem.version || 1
    };

    // 调用单个更新接口
    await updateMaterialItem(updateData);

    // 标记为已更新 ✅ 新增
    updatedItemIds.value.add(existedItem.id);

    ElMessage.success('更新成功');

    // 刷新数据列表
    await initializeData();
  } catch (error: any) {
    if (error !== 'cancel') {
      console.error('更新失败:', error);
      ElMessage.error('更新失败：' + (error.message || '未知错误'));
    }
  }
};
```

**修改点**：

- 新增：更新成功后将 ID 添加到已更新集合

## 状态重置机制

### 1. 导入新数据时重置

```typescript
// 在显示导入结果前清空已更新集合
updatedItemIds.value.clear();
showResult.value = true;
```

**触发时机**：

- 每次导入新的 Excel 文件
- 显示新的导入结果弹窗

### 2. 批量同步时重置

```typescript
// 批量同步成功后清空已更新集合
await batchUpdateMaterialItems(updateItems);
ElMessage.success('批量同步成功');

// 清空已更新集合
updatedItemIds.value.clear();

showResult.value = false;
await initializeData();
```

**说明**：批量同步会更新所有重复物料，因此需要清空已更新记录

## 样式优化

### 禁用按钮样式

```scss
.accumulate-tip {
  // ... 其他样式

  // 全部更新按钮样式
  .el-button {
    &.is-disabled {
      background-color: #909399;
      border-color: #909399;
      color: #ffffff;
      cursor: not-allowed;
      opacity: 0.6;
    }
  }
}
```

**视觉效果**：

- 灰色背景（`#909399`）
- 白色文字
- 降低透明度（`0.6`）
- 鼠标指针变为禁止图标

## 用户交互流程

### 场景 1：全部更新流程

```
用户导入 Excel
    ↓
系统检测到重复物料（3条）
    ↓
显示重复物料详情（包含"全部更新"按钮）
    ↓
用户点击"全部更新"
    ↓
显示确认对话框（展示详细数量信息）
    ↓
用户确认
    ↓
调用 updateMaterialItem 接口
    ↓
更新成功，按钮变为"已更新"（灰色禁用）
    ↓
所有单条更新按钮同步变为"已更新"（灰色禁用）
    ↓
刷新物料列表
```

### 场景 2：单条更新流程

```
用户导入 Excel
    ↓
系统检测到重复物料（3条）
    ↓
用户点击某条记录的"更新"按钮
    ↓
显示确认对话框
    ↓
用户确认
    ↓
调用 updateMaterialItem 接口
    ↓
更新成功，该条记录的按钮变为"已更新"
    ↓
"全部更新"按钮变为"已更新"（灰色禁用）
    ↓
所有单条更新按钮同步变为"已更新"（灰色禁用）
```

### 场景 3：批量同步流程

```
用户导入 Excel
    ↓
系统检测到多个重复物料
    ↓
用户点击右上角"合并同步"按钮
    ↓
批量更新所有重复物料
    ↓
清空已更新集合
    ↓
关闭结果弹窗
    ↓
刷新物料列表
```

## 数据结构示例

### 已更新集合示例

```typescript
// 初始状态
updatedItemIds.value = Set(0) {}

// 用户点击"全部更新"后（物料ID: 123）
updatedItemIds.value = Set(1) { 123 }

// 用户继续更新其他物料（物料ID: 456, 789）
updatedItemIds.value = Set(3) { 123, 456, 789 }

// 导入新数据时清空
updatedItemIds.value = Set(0) {}
```

## API 接口调用

### 全部更新接口调用

```typescript
// PUT /erp/saltprocess/material/item
{
  "id": 123,
  "materialName": "plc控制柜",
  "specification": "见图纸及清单",
  "quantity": 2,  // 累加后的总数量
  "unit": "套",
  "version": 1
}
```

## 优势与亮点

### 1. 用户体验优化

- ✅ 智能显示：只在需要时显示"全部更新"按钮
- ✅ 状态反馈：按钮状态实时反映更新情况
- ✅ 防止误操作：更新后自动禁用，避免重复提交
- ✅ 状态联动：单条和全部更新状态互相关联

### 2. 性能优化

- ✅ 使用 Set 数据结构，查找效率高（O(1)）
- ✅ 最小化接口调用次数
- ✅ 合理的状态管理，避免不必要的重新渲染

### 3. 代码质量

- ✅ 清晰的状态管理
- ✅ 完善的错误处理
- ✅ 用户友好的提示信息
- ✅ 符合 Vue 3 最佳实践

## 注意事项

1. ⚠️ **状态持久化**：已更新状态仅在当前会话有效，刷新页面后重置
2. ⚠️ **并发控制**：使用版本号（version）进行乐观锁控制
3. ⚠️ **错误处理**：接口调用失败不影响状态集合
4. ⚠️ **数据刷新**：更新成功后自动刷新列表，确保数据一致性

## 后续优化建议

1. **批量操作优化**

   - 支持勾选多个物料进行批量全部更新
   - 显示批量更新进度

2. **撤销功能**

   - 记录更新前的数量
   - 支持撤销已更新操作

3. **操作日志**

   - 记录更新操作的时间和用户
   - 支持查看更新历史

4. **状态持久化**
   - 将已更新状态保存到 localStorage
   - 支持跨会话保持状态

## 版本信息

- **版本**：v1.4.0
- **日期**：2025-10-28
- **作者**：haitang
- **功能类型**：新增功能
