# 物料清单分批上传功能实现

## 概述

实现了物料清单数据的分批上传功能，每次上传 10 条数据，有效提高了导入的稳定性和成功率，避免了单次请求数据量过大导致的超时或失败问题。

## 实现目标

1. ✅ 实现数据分批处理，每批 10 条记录
2. ✅ 显示批次进度信息和日志
3. ✅ 自动汇总所有批次的导入结果
4. ✅ 保持发货清单过滤功能
5. ✅ 优化批次间请求间隔

## 核心特性

### 1. 分批上传机制

```typescript
// 每批上传20条数据
const BATCH_SIZE = 20;
// 开发模式判断
const IS_DEV_MODE = import.meta.env.MODE === 'development';

// 计算总批次数
const totalBatches = Math.ceil(validMaterials.length / BATCH_SIZE);

// 分批循环上传
for (let batchIndex = 0; batchIndex < totalBatches; batchIndex++) {
  const start = batchIndex * BATCH_SIZE;
  const end = Math.min(start + BATCH_SIZE, validMaterials.length);
  const batchMaterials = validMaterials.slice(start, end);

  // 【开发模式】批次确认
  if (IS_DEV_MODE && batchIndex > 0) {
    await ElMessageBox.confirm(
      `第 ${batchIndex} 批已上传完成！是否继续？`,
      '开发模式 - 批次确认'
    );
  }

  // 上传当前批次...
}
```

### 2. 批次标识

每个批次都有唯一的批次编号：

```typescript
batchNumber: `${batchNumber}-${group.sheetName}-Batch${batchIndex + 1}`
```

格式示例：`1737123456789-机械设备-Batch1`

### 3. 开发模式批次确认

在开发环境下，每批上传完成后会弹出确认框：

```typescript
if (IS_DEV_MODE && batchIndex > 0) {
  await ElMessageBox.confirm(
    `第 ${batchIndex} 批已上传完成！\n\n` +
      `成功: ${sheetSuccessCount} 条\n` +
      `失败: ${sheetFailedCount} 条\n\n` +
      `是否继续上传第 ${batchIndex + 1} 批？`,
    '开发模式 - 批次确认',
    {
      confirmButtonText: '继续上传',
      cancelButtonText: '停止上传',
      type: 'info'
    }
  );
}
```

**功能说明**：

- ✅ 方便开发测试时观察每批数据的上传情况
- ✅ 可以在任何批次停止上传
- ✅ 显示当前累计上传统计
- ✅ 生产环境自动禁用，不影响正常使用

### 4. 请求间隔控制

批次之间的延迟策略：

```typescript
// 【非开发模式】添加小延迟，避免请求过快
// 【开发模式】由确认框控制节奏，不需要额外延迟
if (!IS_DEV_MODE && batchIndex < totalBatches - 1) {
  await new Promise((resolve) => setTimeout(resolve, 200));
}
```

**说明**：

- **生产环境**：自动添加 200ms 延迟
- **开发环境**：由手动确认控制节奏，无需延迟

### 5. 详细日志输出

每个批次都会输出详细的日志信息：

```typescript
console.info(`Sheet ${group.sheetName}: 共${validMaterials.length}条数据，分${totalBatches}批上传，每批${BATCH_SIZE}条`);
console.info(`正在上传第 ${batchIndex + 1}/${totalBatches} 批，共${batchMaterials.length}条数据...`);
console.info(`✓ 第${batchIndex + 1}批上传成功: ${result.successRecords}条 (累计成功: ${sheetSuccessCount}/${validMaterials.length})`);
```

**开发模式额外日志**：

```typescript
console.info(`✓ 用户确认，继续上传第 ${batchIndex + 1} 批`);
console.warn(`⚠ 用户取消上传，已完成 ${batchIndex} 批`);
```

## 实现细节

### 数据流程

```
1. 解析Excel文件
   ↓
2. 按Sheet分组
   ↓
3. 过滤发货清单 (SHIPPING_INFO)
   ↓
4. 过滤错误记录
   ↓
5. 分批处理 (每批10条)
   ↓
6. 逐批上传数据
   ↓
7. 汇总批次结果
   ↓
8. 显示导入结果
```

### 批次处理逻辑

```typescript
// 遍历每个Sheet
for (const group of sheetGroups.value) {
  // 1. 过滤发货清单
  const filteredMaterials = group.materials.filter((item) => {
    const itemType = item.materialType || materialType;
    return itemType !== 'SHIPPING_INFO';
  });

  // 2. 过滤错误记录
  const validMaterials = filteredMaterials.filter((item) => !item.hasErrors);

  // 3. 计算批次数
  const totalBatches = Math.ceil(validMaterials.length / BATCH_SIZE);

  // 4. 分批上传
  for (let batchIndex = 0; batchIndex < totalBatches; batchIndex++) {
    const batchMaterials = validMaterials.slice(
      batchIndex * BATCH_SIZE,
      Math.min((batchIndex + 1) * BATCH_SIZE, validMaterials.length)
    );

    // 5. 上传当前批次
    const result = await importParsedMaterialData({
      projectId: props.projectId,
      batchNumber: `${batchNumber}-${group.sheetName}-Batch${batchIndex + 1}`,
      materialItems: batchMaterials,
      // ... 其他参数
    });

    // 6. 累计结果
    sheetSuccessCount += result.successRecords || 0;
    sheetFailedCount += result.failedRecords || 0;
  }
}
```

### 结果汇总

每个 Sheet 的批次结果会被汇总：

```typescript
importResults.push({
  sheetName: group.sheetName,
  success: sheetSuccessCount > 0,
  totalRecords: group.materials.length,
  filteredRecords: filteredMaterials.length,
  successRecords: sheetSuccessCount,
  failedRecords: sheetFailedCount,
  newProductRecords: sheetNewProducts,
  matchedProductRecords: sheetMatchedProducts,
  batchCount: totalBatches, // ✨ 批次数量
  skipped: false,
  errors: sheetErrors
});
```

## UI 展示优化

### 导入结果统计

在导入结果摘要中显示总批次数：

```typescript
summary: `共处理 ${processedSheets} 个Sheet(${totalBatches}批次)，有效${validSheets}个，跳过${totalSkipped}条发货清单记录，成功导入 ${totalSuccess} 条物料，失败 ${totalFailed} 条`
```

### Sheet 详情表格

在 Sheet 导入详情表格中增加"批次数"列：

| Sheet 名称 | 总记录数 | 批次数 | 成功 | 失败 | 新建产品 | 匹配产品 | 状态 |
| ---------- | -------- | ------ | ---- | ---- | -------- | -------- | ---- |
| 机械设备   | 50       | 5      | 48   | 2    | 15       | 33       | 成功 |
| 电控设备   | 30       | 3      | 30   | 0    | 10       | 20       | 成功 |

## 性能优化

### 1. 批次大小选择

**批次大小：20 条/次**

选择理由：

- ✅ 请求体积适中（约 20-100KB）
- ✅ 单次请求耗时短（约 1-3 秒）
- ✅ 失败影响范围小
- ✅ 重试成本低
- ✅ 相比 10 条/次，减少了请求总数，提升整体效率

### 2. 请求间隔控制

**间隔时间：200ms**

作用：

- 避免请求过快导致服务器压力
- 防止触发频率限制
- 提供缓冲时间处理前一批次

### 3. 错误隔离

单个批次失败不影响其他批次：

```typescript
try {
  const result = await importParsedMaterialData(importData);
  // 处理成功...
} catch (error: any) {
  // 记录失败，继续下一批次
  sheetFailedCount += batchMaterials.length;
  sheetErrors.push({
    errorMessage: `第${batchIndex + 1}批上传失败: ${error.message}`
  });
}
```

## 使用示例

### 场景 1：少量数据导入（< 20 条）

```
输入: 15条物料记录
处理: 1个批次
结果: 一次性上传完成
```

### 场景 2：中等数据导入（20-100 条）

```
输入: 50条物料记录
处理: 3个批次 (20+20+10)
结果: 分3次上传，每次20条（最后一次10条）
耗时:
  - 生产环境：约3-6秒（包含间隔）
  - 开发环境：根据手动确认速度
```

### 场景 3：大批量数据导入（> 100 条）

```
输入: 250条物料记录
处理: 13个批次 (12×20 + 1×10)
结果: 分13次上传
耗时:
  - 生产环境：约15-30秒
  - 开发环境：根据手动确认速度
```

## 日志输出示例

### 生产环境日志

```
Sheet 机械设备: 共50条数据，分3批上传，每批20条
正在上传第 1/3 批，共20条数据...
✓ 第1批上传成功: 20条 (累计成功: 20/50)
正在上传第 2/3 批，共20条数据...
✓ 第2批上传成功: 20条 (累计成功: 40/50)
正在上传第 3/3 批，共10条数据...
✓ 第3批上传成功: 10条 (累计成功: 50/50)

Sheet 电控设备: 共30条数据，分2批上传，每批20条
正在上传第 1/2 批，共20条数据...
✓ 第1批上传成功: 20条 (累计成功: 20/30)
正在上传第 2/2 批，共10条数据...
✓ 第2批上传成功: 10条 (累计成功: 30/30)

跳过发货清单Sheet: 发货清单，共5条记录
```

### 开发环境日志（带确认框）

```
Sheet 机械设备: 共50条数据，分3批上传，每批20条
正在上传第 1/3 批，共20条数据...
✓ 第1批上传成功: 20条 (累计成功: 20/50)

[弹出确认框：第 1 批已上传完成！成功: 20 条，失败: 0 条。是否继续上传第 2 批？]

✓ 用户确认，继续上传第 2 批
正在上传第 2/3 批，共20条数据...
✓ 第2批上传成功: 20条 (累计成功: 40/50)

[弹出确认框：第 2 批已上传完成！成功: 40 条，失败: 0 条。是否继续上传第 3 批？]

✓ 用户确认，继续上传第 3 批
正在上传第 3/3 批，共10条数据...
✓ 第3批上传成功: 10条 (累计成功: 50/50)
```

## 错误处理

### 批次失败处理

```typescript
catch (error: any) {
  sheetFailedCount += batchMaterials.length;
  sheetErrors.push({
    errorMessage: `第${batchIndex + 1}批上传失败: ${error.message || '未知错误'}`
  });
  console.error(`✗ 第${batchIndex + 1}批上传异常:`, error);
}
```

### 错误类型

| 错误类型     | 处理方式             | 影响范围 |
| ------------ | -------------------- | -------- |
| 网络超时     | 记录失败，继续下一批 | 当前批次 |
| 数据验证失败 | 记录错误信息         | 当前批次 |
| 服务器错误   | 记录失败，继续执行   | 当前批次 |

## 优势对比

### 分批上传 vs 一次性上传

| 对比项         | 分批上传（10 条/次）                | 一次性上传            |
| -------------- | ----------------------------------- | --------------------- |
| **稳定性**     | ⭐⭐⭐⭐⭐ 高                       | ⭐⭐⭐ 中             |
| **成功率**     | ⭐⭐⭐⭐⭐ 高（单批失败不影响整体） | ⭐⭐⭐ 低（全部失败） |
| **重试成本**   | ⭐⭐⭐⭐⭐ 低（只重试失败批次）     | ⭐⭐ 高（重传全部）   |
| **服务器压力** | ⭐⭐⭐⭐ 分散                       | ⭐⭐ 集中             |
| **超时风险**   | ⭐⭐⭐⭐⭐ 低                       | ⭐⭐ 高               |
| **进度可见**   | ⭐⭐⭐⭐⭐ 实时                     | ⭐ 无                 |
| **总耗时**     | 中等（有间隔）                      | 较短                  |

## 注意事项

### 1. 批次大小调整

如需修改批次大小，只需修改常量：

```typescript
const BATCH_SIZE = 10; // 修改此值即可
```

建议范围：5-20 条/批

### 2. 请求间隔调整

如需修改请求间隔：

```typescript
await new Promise((resolve) => setTimeout(resolve, 200)); // 修改延迟时间（毫秒）
```

建议范围：100-500ms

### 3. 大批量导入

对于超大批量导入（> 1000 条）：

- 建议提前告知用户预计耗时
- 考虑显示进度条
- 提供取消功能

### 4. 失败重试

当前实现不会自动重试失败的批次，如需重试：

- 保存失败的批次数据
- 提供"重试失败批次"按钮
- 单独上传失败的数据

## 未来优化建议

### 功能增强

1. **动态批次大小**

   - 根据数据复杂度自动调整批次大小
   - 网络良好时增大批次，网络差时减小批次

2. **进度条显示**

   - 显示当前批次进度
   - 显示预计剩余时间
   - 可视化批次上传状态

3. **失败重试机制**

   - 自动重试失败的批次（最多 3 次）
   - 指数退避策略
   - 提供手动重试按钮

4. **并发上传**
   - 同时上传多个批次（控制并发数）
   - 进一步提高上传速度
   - 需要控制并发数避免服务器压力

### 性能优化

1. **智能批次调度**

   - 优先上传小批次
   - 错误批次延后处理
   - 提高整体成功率

2. **断点续传**

   - 记录已上传的批次
   - 刷新页面后可继续上传
   - 避免重复上传

3. **数据压缩**
   - 压缩请求体
   - 减少网络传输时间
   - 提高上传效率

## 版本信息

- **版本号**: v1.2.0
- **更新日期**: 2025-01-16
- **功能**: 分批上传（10 条/次）
- **兼容性**: 完全兼容现有接口

## 相关文档

- [物料导入接口调用优化实现总结](./物料导入接口调用优化实现总结.md)
- [前端物料导入接口文档](./前端物料导入接口文档.md)
- [物料导入 API 调用示例](./物料导入API调用示例.ts)

---

## 总结

分批上传功能的实现大幅提升了物料清单导入的稳定性和成功率：

1. ✅ **稳定性提升**：单批失败不影响整体
2. ✅ **成功率提高**：避免大数据量导致的超时
3. ✅ **错误隔离**：失败影响范围最小化
4. ✅ **进度可见**：实时日志输出
5. ✅ **性能优化**：请求间隔控制，避免服务器压力

该实现为用户提供了更加可靠和友好的数据导入体验。
