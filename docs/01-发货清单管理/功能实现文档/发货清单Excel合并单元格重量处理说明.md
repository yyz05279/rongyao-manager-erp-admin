# 发货清单Excel合并单元格重量处理说明

## 核心概念

### Excel中的合并单元格重量

在实际的发货场景中，经常会出现**多个设备打包在一起发货，只能一起称重**的情况。在Excel中，这种情况表现为**重量列的合并单元格**。

### 示例说明

| 序号 | 名称       | 分项       | 数量 | 单位 | 重量（吨） |
| ---- | ---------- | ---------- | ---- | ---- | ---------- |
| 1    | 平面输送机 | 输送主体   | 2    | 套   | **7** ←    |
| 1    | 平面输送机 | 紧固件     | 1    | 套   | **7** ← 合并单元格 |
| 2    | 子输送     | 卸料溜壳   | 2    | 套   | **7** ←    |
| 2    | 子输送     | 紧固件     | 1    | 套   | **7** ←    |
| 3    | 粉碎机     | 粉碎机本体 | 2    | 套   | **7.5** ← |
| 3    | 粉碎机     | 油缸及油管 | 8    | 套   | **7.5** ← 合并单元格 |

**关键理解**:
- **序号1（平面输送机）+ 序号2（子输送）**: 打包在一起发货，一起称重，总重7吨
- **序号3（粉碎机）**: 单独发货，总重7.5吨

### 重要区分

❌ **错误理解**: 
- 每个设备都是7吨 → 总重 = 7 + 7 + 7.5 = 21.5吨（错误！）

✅ **正确理解**:
- 序号1+序号2 **共计** 7吨（打包发货，一起称重）
- 序号3 **单独** 7.5吨
- 总重 = 7 + 7.5 = 14.5吨

## 数据处理逻辑

### 1. 按连续相同重量分组

系统会自动检测Excel中连续相同的重量值，将它们分为一组：

```typescript
// 重量值 7 连续出现 → 分为一组
组1: [序号1-平面输送机, 序号2-子输送] → 重量: 7吨

// 重量值 7.5 连续出现 → 分为另一组
组2: [序号3-粉碎机] → 重量: 7.5吨
```

### 2. 生成子系统重量数据

```json
{
  "subsystemWeights": [
    {
      "subsystem": "序号1-平面输送机+序号2-子输送",
      "weight": 7,
      "remarks": "平面输送机+子输送总重"
    },
    {
      "subsystem": "序号3-粉碎机",
      "weight": 7.5,
      "remarks": "粉碎机总重"
    }
  ]
}
```

### 3. 子项关联

所有属于同一重量组的子项，都会关联到同一个子系统：

```json
{
  "shippingItems": [
    // 序号1的所有子项
    {
      "equipmentName": "平面输送机",
      "subItemName": "输送主体",
      "subsystem": "序号1-平面输送机+序号2-子输送",  // ← 指向组合子系统
      "weight": undefined
    },
    {
      "equipmentName": "平面输送机",
      "subItemName": "紧固件",
      "subsystem": "序号1-平面输送机+序号2-子输送",  // ← 同一组
      "weight": undefined
    },
    
    // 序号2的所有子项
    {
      "equipmentName": "子输送",
      "subItemName": "卸料溜壳",
      "subsystem": "序号1-平面输送机+序号2-子输送",  // ← 同一组
      "weight": undefined
    },
    
    // 序号3的所有子项
    {
      "equipmentName": "粉碎机",
      "subItemName": "粉碎机本体",
      "subsystem": "序号3-粉碎机",  // ← 独立子系统
      "weight": undefined
    }
  ]
}
```

## 实现细节

### 算法流程

```typescript
/**
 * 提取子系统重量数据
 * 核心：按连续相同重量值分组
 */
function extractSubsystemWeights() {
  let currentWeight = null;
  let currentEquipments = [];
  
  // 遍历所有数据行
  for (const row of data) {
    const weight = row.重量;
    
    // 重量值改变了
    if (weight !== currentWeight) {
      // 保存之前的分组
      if (currentWeight > 0) {
        saveGroup(currentEquipments, currentWeight);
      }
      
      // 开始新的分组
      currentWeight = weight;
      currentEquipments = [];
    }
    
    // 添加到当前分组
    if (weight > 0) {
      currentEquipments.push(row.设备);
    }
  }
  
  // 保存最后一个分组
  if (currentWeight > 0) {
    saveGroup(currentEquipments, currentWeight);
  }
}
```

### 关键特性

1. **顺序依赖**: 按Excel中的行顺序处理，连续相同重量值会被分为一组
2. **去重**: 使用Set避免同一设备重复添加
3. **易读性**: `remarks`字段只显示设备名称（去掉"序号X-"前缀）

## 控制台调试输出

导入时会输出详细的分组信息：

```
=== 📊 数据提取检查 ===

📦 子系统重量数组（格式化）:
[
  {
    "subsystem": "序号1-平面输送机+序号2-子输送",
    "weight": 7,
    "remarks": "平面输送机+子输送总重"
  },
  {
    "subsystem": "序号3-粉碎机",
    "weight": 7.5,
    "remarks": "粉碎机总重"
  }
]

子系统数量: 2
所有子系统总重量: 14.5 吨

📋 子系统重量明细表:
┌─────────┬─────────────────────────────────────┬──────────┬──────────────────────┐
│ (index) │              子系统                 │   重量   │         备注         │
├─────────┼─────────────────────────────────────┼──────────┼──────────────────────┤
│    0    │ '序号1-平面输送机+序号2-子输送'     │  '7吨'   │ '平面输送机+子输送总重' │
│    1    │ '序号3-粉碎机'                      │ '7.5吨'  │   '粉碎机总重'       │
└─────────┴─────────────────────────────────────┴──────────┴──────────────────────┘

📊 每个子系统的子项数量:
┌─────────┬─────────────────────────────────────┬────────────┐
│ (index) │              子系统                 │ 子项数量   │
├─────────┼─────────────────────────────────────┼────────────┤
│    0    │ '序号1-平面输送机+序号2-子输送'     │   '6项'    │
│    1    │ '序号3-粉碎机'                      │   '9项'    │
└─────────┴─────────────────────────────────────┴────────────┘
```

## 验证要点

### ✅ 正确的数据结构

1. **子系统命名**: 多个设备用"+"连接，如 `序号1-平面输送机+序号2-子输送`
2. **重量不重复**: 总重量 = 各子系统重量之和（不是所有行的累加）
3. **子项关联正确**: 同一重量组的所有子项，`subsystem`字段相同
4. **子项重量为空**: 所有子项的`weight`都是`undefined`

### ❌ 常见错误

1. **重复累加**: 7 + 7 + 7 + 7 + 7.5 + 7.5 = 35吨（错误！）
2. **单独分组**: 序号1、序号2各自独立，各7吨（错误！）
3. **平均分配**: 序号1和序号2各3.5吨（错误！）

## 业务场景说明

### 为什么会有合并单元格？

在实际发货中，经常遇到以下情况：

1. **设备体积大**: 平面输送机和子输送都很大，需要打包在一起
2. **无法单独称重**: 打包后无法拆开，只能整体称重
3. **记录真实情况**: Excel中的合并单元格真实反映了这种打包发货的情况

### 系统如何处理？

1. **识别分组**: 自动识别Excel中的合并单元格（连续相同重量值）
2. **生成组合子系统**: 将打包的设备组合成一个子系统
3. **准确统计**: 总重量 = 各组合子系统的重量之和

## 后端处理

后端根据`subsystemWeights`数组进行处理：

```java
// 统计总重量
BigDecimal totalWeight = subsystemWeights.stream()
    .map(SubsystemWeight::getWeight)
    .reduce(BigDecimal.ZERO, BigDecimal::add);

// 结果: 7 + 7.5 = 14.5吨 ✅
```

## 总结

| 维度 | Excel显示 | 系统理解 | 数据结构 |
|------|-----------|----------|----------|
| **序号1+序号2** | 重量列合并，显示7吨 | 打包发货，共重7吨 | 一个子系统，weight: 7 |
| **序号3** | 重量列合并，显示7.5吨 | 独立发货，重7.5吨 | 一个子系统，weight: 7.5 |
| **总重量** | - | 14.5吨 | subsystemWeights数组累加 |

**关键原则**: Excel中的合并单元格 = 打包发货的设备组 = 系统中的一个子系统

---

**文档版本**: v1.0  
**创建时间**: 2025-10-30  
**适用场景**: 多设备打包发货，共享重量值

