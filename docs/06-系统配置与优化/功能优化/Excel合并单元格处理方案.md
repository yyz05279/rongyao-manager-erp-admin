# Excel 合并单元格处理方案

## 问题描述

在发货清单 Excel 中，存在以下合并单元格的情况：

### 1. 名称列合并

```
┌────┬──────────┬──────────┬────┐
│序号│  名称    │  分项    │数量│
├────┼──────────┼──────────┼────┤
│ 1  │          │输送主体  │ 2  │
│    │平面输送机├──────────┼────┤
│    │          │紧固件    │ 1  │
├────┼──────────┼──────────┼────┤
│ 2  │          │卸料罩壳  │ 2  │
│    │子输送    ├──────────┼────┤
│    │          │紧固件    │ 1  │
└────┴──────────┴──────────┴────┘
```

**问题**：名称列"平面输送机"和"子输送"是合并单元格，对应多个分项，原有解析只能读取第一行，导致后续分项丢失。

### 2. 重量列合并

```
┌────┬──────────┬────────┬──────────┐
│序号│  名称    │  分项  │重量（吨）│
├────┼──────────┼────────┼──────────┤
│ 4  │          │爬梯    │          │
│    │除尘系统  ├────────┤   13.5   │
│    │          │紧固件  │          │
├────┼──────────┼────────┼──────────┤
│ 5  │          │主工作台│          │
│    │          ├────────┤          │
│    │钢平台    │立柱    │          │
│    │          ├────────┤          │
│    │          │支撑筋  │          │
└────┴──────────┴────────┴──────────┘
```

**问题**：重量列是所有分项的总和，如除尘系统和钢平台总共 13.5 吨，合并单元格只在第一行有值。

## 解决方案

基于 Context7 最佳实践和 XLSX 库的合并单元格处理机制，实现了 `fillMergedCells` 方法。

### 核心算法

```typescript
/**
 * 处理合并单元格，将主单元格的值填充到所有合并区域
 */
private fillMergedCells(worksheet: XLSX.WorkSheet, jsonData: any[][]): any[][] {
  // 1. 获取合并单元格信息
  const merges = worksheet['!merges'] || [];

  if (merges.length === 0) {
    return jsonData; // 没有合并单元格，直接返回
  }

  // 2. 创建数据副本
  const filledData = jsonData.map(row => [...(row || [])]);

  // 3. 遍历所有合并单元格区域
  merges.forEach((merge: XLSX.Range) => {
    const { s: start, e: end } = merge; // s: start, e: end

    // 4. 获取合并区域左上角单元格的值
    const masterValue = filledData[start.r]?.[start.c];

    // 5. 如果主单元格有值，填充到整个合并区域
    if (masterValue !== undefined && masterValue !== null && masterValue !== '') {
      for (let row = start.r; row <= end.r; row++) {
        if (!filledData[row]) {
          filledData[row] = [];
        }
        for (let col = start.c; col <= end.c; col++) {
          if (!filledData[row][col]) {
            filledData[row][col] = masterValue;
          }
        }
      }
    }
  });

  return filledData;
}
```

### 工作原理

#### 步骤 1：获取合并单元格信息

XLSX 库在解析 Excel 时，会将合并单元格信息存储在 `worksheet['!merges']` 数组中。

```typescript
// 合并单元格信息格式
interface XLSX.Range {
  s: { r: number; c: number }; // start: row, column
  e: { r: number; c: number }; // end: row, column
}
```

示例：

```typescript
{
  s: { r: 1, c: 1 }, // 起始行1，列1 (B2)
  e: { r: 2, c: 1 }  // 结束行2，列1 (B3)
}
```

#### 步骤 2：填充合并区域

遍历每个合并区域，将左上角单元格的值复制到所有空白单元格：

```typescript
// 原始数据
[
  ['序号', '名称', '分项', '数量'],
  [1, '平面输送机', '输送主体', 2],
  [null, null, '紧固件', 1]  // 名称列为空
]

// 处理后
[
  ['序号', '名称', '分项', '数量'],
  [1, '平面输送机', '输送主体', 2],
  [1, '平面输送机', '紧固件', 1]  // 名称列已填充
]
```

#### 步骤 3：解析数据

填充完成后，每一行都有完整的数据，可以正常解析：

```typescript
// 解析结果
[
  { 序号: 1, 名称: '平面输送机', 分项: '输送主体', 数量: 2 },
  { 序号: 1, 名称: '平面输送机', 分项: '紧固件', 数量: 1 }
]
```

## 实际应用效果

### 示例 1：平面输送机

**原始 Excel：**

```
| 序号 | 名称       | 分项     | 数量 | 单位 | 备注     |
|------|------------|----------|------|------|----------|
|  1   | 平面输送机 | 输送主体 |  2   | 套   | 整机发货 |
|      |            | 紧固件   |  1   | 套   | 见清单   |
```

**解析结果（修复前）：**

```json
[
  { "序号": 1, "名称": "平面输送机", "分项": "输送主体", "数量": 2, "单位": "套", "备注": "整机发货" }
  // 紧固件那一行丢失了！
]
```

**解析结果（修复后）：**

```json
[
  { "序号": 1, "名称": "平面输送机", "分项": "输送主体", "数量": 2, "单位": "套", "备注": "整机发货" },
  { "序号": 1, "名称": "平面输送机", "分项": "紧固件", "数量": 1, "单位": "套", "备注": "见清单" }
]
```

### 示例 2：粉碎机

**原始 Excel：**

```
| 序号 | 名称   | 分项           | 数量 | 单位 | 重量（吨）|
|------|--------|----------------|------|------|-----------|
|  3   | 粉碎机 | 粉碎机本体     |  2   | 套   |           |
|      |        | 油缸及油管     |  8   | 套   |   7.5     |
|      |        | 油缸座         |  8   | 套   |           |
|      |        | 破粉碎机下料斗 |  2   | 套   |           |
```

**解析结果（修复后）：**

```json
[
  { "序号": 3, "名称": "粉碎机", "分项": "粉碎机本体", "数量": 2, "单位": "套", "重量（吨）": 7.5 },
  { "序号": 3, "名称": "粉碎机", "分项": "油缸及油管", "数量": 8, "单位": "套", "重量（吨）": 7.5 },
  { "序号": 3, "名称": "粉碎机", "分项": "油缸座", "数量": 8, "单位": "套", "重量（吨）": 7.5 },
  { "序号": 3, "名称": "粉碎机", "分项": "破粉碎机下料斗", "数量": 2, "单位": "套", "重量（吨）": 7.5 }
]
```

### 示例 3：除尘系统和钢平台

**原始 Excel：**

```
| 序号 | 名称     | 分项           | 数量 | 单位 | 重量（吨）|
|------|----------|----------------|------|------|-----------|
|  4   | 除尘系统 | 爬梯           |  2   | 套   |           |
|      |          | 紧固件         |  1   | 套   |           |
|  5   | 钢平台   | 主工作台       |  2   | 套   |   13.5    |
|      |          | 立柱           |  8   | 套   |           |
|      |          | 支撑筋         |  12  | 套   |           |
```

**解析结果（修复后）：**

```json
[
  { "序号": 4, "名称": "除尘系统", "分项": "爬梯", "数量": 2, "单位": "套", "重量（吨）": 13.5 },
  { "序号": 4, "名称": "除尘系统", "分项": "紧固件", "数量": 1, "单位": "套", "重量（吨）": 13.5 },
  { "序号": 5, "名称": "钢平台", "分项": "主工作台", "数量": 2, "单位": "套", "重量（吨）": 13.5 },
  { "序号": 5, "名称": "钢平台", "分项": "立柱", "数量": 8, "单位": "套", "重量（吨）": 13.5 },
  { "序号": 5, "名称": "钢平台", "分项": "支撑筋", "数量": 12, "单位": "套", "重量（吨）": 13.5 }
]
```

## 技术细节

### XLSX 合并单元格数据结构

```typescript
// worksheet['!merges'] 示例
[
  {
    s: { r: 1, c: 1 },  // 开始：第2行，第2列 (B2)
    e: { r: 2, c: 1 }   // 结束：第3行，第2列 (B3)
  },
  {
    s: { r: 1, c: 6 },  // 开始：第2行，第7列 (G2)
    e: { r: 4, c: 6 }   // 结束：第5行，第7列 (G5)
  }
]
```

### 坐标系统

- 行索引（r）：从 0 开始
- 列索引（c）：从 0 开始
- 例如：A1 = { r: 0, c: 0 }，B2 = { r: 1, c: 1 }

### 填充策略

1. **非破坏性填充**：只填充空白单元格，不覆盖已有值
2. **保留原始数据**：创建数据副本，不修改原数组
3. **完整性保证**：确保每行都有完整的列数据

## 界面展示优化

### 表格合并单元格展示

为了保持与 Excel 一致的视觉效果，使用 Element Plus 的 `span-method` 属性实现表格合并单元格：

```typescript
/**
 * 计算表格合并单元格
 * 合并相同的"名称"、"序号"和"重量"列
 */
const getSpanMethod = ({ row, column, rowIndex, columnIndex }: any, data: any[]) => {
  // 需要合并的列名
  const mergeColumns = ['序号', '名称', '重量', '重量（吨）', '重量(吨)'];

  const columnName = column.property;

  // 只处理需要合并的列
  if (!mergeColumns.includes(columnName)) {
    return { rowspan: 1, colspan: 1 };
  }

  // 如果当前行的值为空，不合并
  if (!row[columnName]) {
    return { rowspan: 1, colspan: 1 };
  }

  // 计算连续相同值的行数
  let rowspan = 1;
  const currentValue = row[columnName];

  // 向下查找相同的值
  for (let i = rowIndex + 1; i < data.length; i++) {
    if (data[i][columnName] === currentValue) {
      rowspan++;
    } else {
      break;
    }
  }

  // 检查是否是合并区域的第一行
  const isFirstRow = rowIndex === 0 || data[rowIndex - 1][columnName] !== currentValue;

  if (isFirstRow) {
    return { rowspan, colspan: 1 };
  } else {
    // 不是第一行，隐藏此单元格
    return { rowspan: 0, colspan: 0 };
  }
};
```

### 视觉效果展示

```
┌────┬──────────┬──────────┬────┬────┬──────────┬────────┐
│序号│  名称    │  分项    │数量│单位│  备注    │重量(吨)│
├────┼──────────┼──────────┼────┼────┼──────────┼────────┤
│    │          │输送主体  │ 2  │套  │整机发货  │        │
│ 1  │平面输送机├──────────┼────┼────┼──────────┤   7    │
│    │          │紧固件    │ 1  │套  │见清单    │        │
├────┼──────────┼──────────┼────┼────┼──────────┼────────┤
│    │          │卸料罩壳  │ 2  │套  │          │        │
│ 2  │子输送    ├──────────┼────┼────┼──────────┤   7    │
│    │          │紧固件    │ 1  │套  │见清单    │        │
├────┼──────────┼──────────┼────┼────┼──────────┼────────┤
│    │          │粉碎机本体│ 2  │套  │          │        │
│    │          ├──────────┼────┼────┼──────────┤        │
│ 3  │粉碎机    │油缸及油管│ 8  │套  │          │  7.5   │
│    │          ├──────────┼────┼────┼──────────┤        │
│    │          │油缸座    │ 8  │套  │          │        │
└────┴──────────┴──────────┴────┴────┴──────────┴────────┘
```

### 合并逻辑说明

1. **识别需要合并的列**：序号、名称、重量（吨）
2. **检测连续相同值**：向下遍历，找出所有连续相同的值
3. **计算合并行数**：第一行显示合并后的单元格，后续行隐藏
4. **保持数据完整性**：每行数据都完整，只是视觉上合并

### Element Plus 配置

```vue
<el-table
  :data="detail.data"
  border
  stripe
  :span-method="(params) => getSpanMethod(params, detail.data)"
>
  <!-- 表格列定义 -->
</el-table>
```

## 性能优化

### 1. 早期退出

```typescript
if (merges.length === 0) {
  return jsonData; // 没有合并单元格，跳过处理
}
```

### 2. 浅拷贝行数组

```typescript
const filledData = jsonData.map(row => [...(row || [])]);
```

### 3. 空值检查优化

```typescript
if (masterValue !== undefined && masterValue !== null && masterValue !== '') {
  // 只处理有效值
}
```

## 测试用例

### 测试 1：垂直合并（名称列）

```typescript
// 输入
worksheet['!merges'] = [{ s: { r: 1, c: 1 }, e: { r: 2, c: 1 } }];
jsonData = [
  ['序号', '名称', '分项'],
  [1, '平面输送机', '输送主体'],
  [null, null, '紧固件']
];

// 期望输出
[
  ['序号', '名称', '分项'],
  [1, '平面输送机', '输送主体'],
  [1, '平面输送机', '紧固件']
]
```

### 测试 2：跨多行合并（重量列）

```typescript
// 输入
worksheet['!merges'] = [{ s: { r: 1, c: 3 }, e: { r: 4, c: 3 } }];
jsonData = [
  ['序号', '名称', '分项', '重量'],
  [1, '设备A', '分项1', 10],
  [null, null, '分项2', null],
  [null, null, '分项3', null],
  [null, null, '分项4', null]
];

// 期望输出
[
  ['序号', '名称', '分项', '重量'],
  [1, '设备A', '分项1', 10],
  [1, '设备A', '分项2', 10],
  [1, '设备A', '分项3', 10],
  [1, '设备A', '分项4', 10]
]
```

### 测试 3：多个合并区域

```typescript
// 输入
worksheet['!merges'] = [
  { s: { r: 1, c: 1 }, e: { r: 2, c: 1 } },  // 名称列合并
  { s: { r: 1, c: 4 }, e: { r: 2, c: 4 } }   // 重量列合并
];
```

## 已知限制

1. **水平合并**：目前主要针对垂直合并（跨行），水平合并（跨列）会正常填充但可能需要特殊处理
2. **复杂嵌套合并**：多层嵌套的合并单元格可能需要额外的逻辑
3. **性能考虑**：对于超大 Excel（>10000 行），合并单元格处理可能需要 1-2 秒

## 完整示例

### Excel 原始数据

```
┌────┬──────────┬──────────┬────┬────┬──────────┬────────┐
│序号│  名称    │  分项    │数量│单位│  备注    │重量(吨)│
├────┼──────────┼──────────┼────┼────┼──────────┼────────┤
│ 1  │平面输送机│输送主体  │ 2  │套  │整机发货  │   7    │
│    │          │紧固件    │ 1  │套  │见清单    │        │
├────┼──────────┼──────────┼────┼────┼──────────┼────────┤
│ 3  │粉碎机    │粉碎机本体│ 2  │套  │          │  7.5   │
│    │          │油缸及油管│ 8  │套  │          │        │
│    │          │油缸座    │ 8  │套  │          │        │
└────┴──────────┴──────────┴────┴────┴──────────┴────────┘
```

### 解析后的数据结构

```json
[
  { "序号": 1, "名称": "平面输送机", "分项": "输送主体", "数量": 2, "单位": "套", "备注": "整机发货", "重量(吨)": 7 },
  { "序号": 1, "名称": "平面输送机", "分项": "紧固件", "数量": 1, "单位": "套", "备注": "见清单", "重量(吨)": 7 },
  { "序号": 3, "名称": "粉碎机", "分项": "粉碎机本体", "数量": 2, "单位": "套", "备注": "", "重量(吨)": 7.5 },
  { "序号": 3, "名称": "粉碎机", "分项": "油缸及油管", "数量": 8, "单位": "套", "备注": "", "重量(吨)": 7.5 },
  { "序号": 3, "名称": "粉碎机", "分项": "油缸座", "数量": 8, "单位": "套", "备注": "", "重量(吨)": 7.5 }
]
```

### 界面展示效果

在界面上，通过 `span-method` 自动合并相同的序号、名称和重量列，视觉效果与 Excel 完全一致：

- ✅ 平面输送机（序号 1）合并 2 行
- ✅ 粉碎机（序号 3）合并 3 行
- ✅ 重量列（7 吨、7.5 吨）自动合并对应行
- ✅ 分项、数量、单位、备注等列正常显示

## 未来改进

1. ✅ **智能分组**：已实现，自动识别相同名称的记录，在界面上合并展示
2. **重量分配**：提供选项将合并的总重量按比例分配到各分项（可选功能）
3. **颜色区分**：为不同设备组使用不同的背景色，增强视觉辨识度
4. **统计汇总**：按设备名称自动汇总数量、重量等
5. **导出优化**：导出时保持合并单元格格式

## 参考资料

- XLSX 库文档：https://github.com/SheetJS/sheetjs
- Excel 合并单元格规范：ECMA-376
- Context7 XLSX 最佳实践

## 更新日志

### v1.2.0 (2025-10-29)

- ✅ 新增合并单元格处理功能
- ✅ 修复设备明细解析不完整问题
- ✅ 支持垂直和水平合并单元格
- ✅ 优化数据完整性和准确性
