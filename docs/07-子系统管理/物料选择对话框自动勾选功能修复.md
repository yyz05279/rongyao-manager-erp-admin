# 物料选择对话框自动勾选功能修复

## 问题描述

在子项模板管理页面中，打开物料选择对话框时，虽然控制台打印了"已自动勾选 2 个已添加的物料"，但是列表上没有显示勾选的状态。

**更新（2025-11-19）**：在设备系统模板管理中也发现了类似问题，传入的 `existingMaterialIds` 数组包含 `NaN` 值，导致无法正确匹配已添加的物料。

## 问题分析

### 1. 缺少自动勾选逻辑

`src/views/erp/subsystem/item-template/components/MaterialSelectorDialog.vue` 组件缺少以下关键功能：
- 缺少 `tableRef` 引用
- 缺少 `autoSelectAddedMaterials` 函数
- 缺少 `nextTick` 导入
- 没有在数据加载完成后调用自动勾选

### 2. 数据匹配方式错误

#### 2.1 子系统模板的问题
原始代码使用 `materialId` 进行匹配，但实际接口返回的数据结构中：
- `/saltprocess/equipmentSystemTemplate/item/{id}/materials` 返回的物料关联记录中包含 `materialCode` 字段
- `/saltprocess/material/item/list` 返回的物料列表中也包含 `materialCode` 字段
- 应该使用 `materialCode` 进行匹配，而不是 `materialId`

#### 2.2 设备系统模板的问题（2025-11-19 新增）
设备系统模板的物料管理存在更复杂的问题：

**问题根源**：
- 设备系统模板的物料是从基础物料库**复制**的（通过 `addEquipmentSystemItemMaterialFromBase` API）
- 复制后的物料模板**失去了与基础物料的关联**（没有 `materialId` 外键字段）
- API 返回的物料模板数据结构：
  ```json
  {
    "id": "1990954165500583937",           // 物料模板ID（不是基础物料ID）
    "materialCode": "MAT-1762231954243-CC24",  // 物料编码（从基础物料复制）
    "materialName": "弯头",
    ...
  }
  ```

**错误的实现**：
```typescript
// ❌ 错误：物料模板数据中没有 materialId 字段
const existingMaterialIds = computed(() => {
  return materialList.value.map(item => Number(item.materialId));  // item.materialId 是 undefined
});
// 结果：[NaN, NaN, NaN, ...]
```

**正确的实现**：
```typescript
// ✅ 正确：使用 materialCode 字段进行匹配
const existingMaterialCodes = computed<string[]>(() => {
  return materialList.value
    .map(item => item.materialCode)
    .filter((code): code is string => Boolean(code));
});
```

## 修复方案

### 1. MaterialSelectorDialog 组件修改

#### 1.1 添加 tableRef 引用

```vue
<el-table
  ref="tableRef"
  v-loading="loading"
  :data="materialList"
  @selection-change="handleSelectionChange"
  style="width: 100%"
  height="450"
>
```

#### 1.2 导入 nextTick 并添加 tableRef 变量

```typescript
import { ref, reactive, computed, watch, nextTick } from 'vue';

const tableRef = ref();
```

#### 1.3 修改 Props 定义（2025-11-19 更新）

支持两种匹配方式：通过 ID 匹配（子系统模板）和通过编码匹配（设备系统模板）

```typescript
// Props
interface Props {
  modelValue: boolean;
  existingMaterialIds?: number[];   // 已添加的物料ID列表（用于ID匹配）
  existingMaterialCodes?: string[]; // 已添加的物料编码列表（用于编码匹配）
}

const props = withDefaults(defineProps<Props>(), {
  existingMaterialIds: () => [],
  existingMaterialCodes: () => []
});
```

#### 1.4 实现自动勾选逻辑（2025-11-19 更新）

支持两种匹配方式：

```typescript
// 检查物料是否已添加
const isAdded = (row: MaterialVO): boolean => {
  // 优先使用 materialCode 匹配（用于设备系统模板）
  if (props.existingMaterialCodes.length > 0 && row.materialCode) {
    const resultByCode = props.existingMaterialCodes.includes(row.materialCode);
    console.log(`检查物料 ${row.materialName}(编码: ${row.materialCode}) 是否已添加(通过编码):`, resultByCode);
    return resultByCode;
  }

  // 否则使用 ID 匹配（用于子系统模板）
  const resultById = props.existingMaterialIds.includes(row.id as number);
  console.log(`检查物料 ${row.materialName}(ID: ${row.id}) 是否已添加(通过ID):`, resultById);
  return resultById;
};

// 自动勾选已添加的物料
const autoSelectAddedMaterials = async () => {
  await nextTick();

  console.log('========== 开始自动勾选物料 ==========');
  console.log('existingMaterialCodes:', props.existingMaterialCodes);
  console.log('materialList:', materialList.value);

  if (!tableRef.value) {
    console.warn('表格组件未找到，无法自动勾选');
    return;
  }

  tableRef.value.clearSelection();

  let selectedCount = 0;
  materialList.value.forEach((material) => {
    const materialCode = material.materialCode;
    const isInExisting = materialCode && props.existingMaterialCodes.includes(materialCode);
    
    console.log(`检查物料 ${material.materialName} (code: ${materialCode}):`, {
      isAdded: isAdded(material),
      inExistingCodes: isInExisting
    });

    if (isAdded(material)) {
      console.log('✓ 勾选物料:', materialCode, material.materialName);
      tableRef.value.toggleRowSelection(material, true);
      selectedCount++;
    }
  });

  console.log(`已自动勾选 ${selectedCount} 个已添加的物料`);
  console.log('========== 自动勾选完成 ==========');
};

// 在加载物料列表后调用
const loadMaterialList = async () => {
  loading.value = true;
  try {
    const response: any = await listMaterial(queryParams);
    // ... 处理响应数据

    // 自动勾选已添加的物料
    autoSelectAddedMaterials();
  } catch (error) {
    // ... 错误处理
  } finally {
    loading.value = false;
  }
};
```

### 2. 父组件修改

#### 2.1 修改计算属性（2025-11-19 更新）

**设备系统模板**（`ItemTemplateManagement.vue` with `useEquipmentSystemApi=true`）：

```typescript
// 计算已存在的物料编码列表（用于物料选择器中的自动勾选）
// 注意：设备系统模板的物料是从基础物料库复制的，复制后失去了与基础物料的关联
// 但是 materialCode 字段会被保留，所以我们可以通过 materialCode 来匹配
const existingMaterialCodes = computed<string[]>(() => {
  const codes = materialList.value
    .map(item => item.materialCode)
    .filter((code): code is string => Boolean(code)); // 类型守卫，过滤掉空值并确保类型为 string
  console.log('计算 existingMaterialCodes:', codes);
  console.log('materialList.value:', materialList.value);
  return codes;
});
```

**子系统模板**（原有逻辑保持不变）：

```typescript
// 计算已存在的物料编码列表（用于物料选择对话框的去重）
const existingMaterialCodes = computed(() => {
  return materialList.value.map(item => item.materialCode).filter(Boolean);
});

// 计算新增子项表单中已选择的物料编码列表
const itemFormMaterialCodes = computed(() => {
  return form.materials?.map(item => item.materialCode).filter(Boolean) || [];
});
```

#### 2.2 修改组件调用

```vue
<!-- 物料选择对话框（用于子项详情中添加物料） -->
<material-selector-dialog
  v-model="materialSelectorVisible"
  :existing-material-codes="existingMaterialCodes"
  @confirm="handleMaterialsSelected"
/>

<!-- 物料选择对话框（用于新增子项时添加物料） -->
<material-selector-dialog
  v-model="itemMaterialSelectorVisible"
  :existing-material-codes="itemFormMaterialCodes"
  @confirm="handleItemMaterialsSelected"
/>
```

#### 2.3 修改物料添加逻辑

```typescript
// 处理新增子项时选择的物料
const handleItemMaterialsSelected = (materials: MaterialVO[]) => {
  if (!form.materials) {
    form.materials = [];
  }

  materials.forEach(material => {
    // 避免重复添加（使用 materialCode 判断）
    if (!form.materials!.some(m => m.materialCode === material.materialCode)) {
      form.materials!.push({
        materialId: material.id as number,
        materialCode: material.materialCode, // 保存物料编码
        materialName: material.materialName,
        defaultQuantity: 1,
        isRequired: true,
        remarks: ''
      } as any);
    }
  });

  formRef.value?.validateField('materials');
};
```

### 3. 类型定义修改

在 `src/api/erp/subsystem/types.ts` 中添加 `materialCode` 字段：

```typescript
export interface MaterialItem {
  materialId: number;                // 物料ID（必填）
  materialCode?: string;             // 物料编码（用于前端去重和显示）
  materialName?: string;             // 物料名称（用于前端显示）
  defaultQuantity?: number;          // 默认数量
  isRequired?: boolean;              // 是否必需
  remarks?: string;                  // 备注
}
```

## 修复效果

1. ✅ 打开物料选择对话框时，已添加的物料会自动勾选
2. ✅ 已添加的物料显示"已添加"标签，且不可再次选择
3. ✅ 使用 `materialCode` 进行精确匹配，避免ID类型不一致的问题
4. ✅ 添加详细的控制台日志，方便调试
5. ✅ **（2025-11-19）** 修复设备系统模板中 `existingMaterialIds` 为 `NaN` 的问题
6. ✅ **（2025-11-19）** 支持两种匹配方式：ID 匹配和编码匹配

## 测试步骤

1. 打开子项模板管理页面
2. 点击某个子项的"查看物料"按钮
3. 在物料列表对话框中点击"添加物料"
4. 观察物料选择对话框中，已添加的物料是否自动勾选
5. 检查控制台日志，确认匹配逻辑正确

## 相关文件

### 子系统模板
- `src/views/erp/subsystem/item-template/components/MaterialSelectorDialog.vue`
- `src/views/erp/subsystem/item-template/index.vue`
- `src/api/erp/subsystem/types.ts`

### 设备系统模板（2025-11-19 新增）
- `src/views/erp/subsystem/template/components/MaterialSelectorDialog.vue`
- `src/views/erp/subsystem/template/components/ItemTemplateManagement.vue`
- `src/api/erp/saltprocess/equipment-system/template.ts`

## 技术要点总结

### 1. 物料关联模式的差异

| 模式 | 物料存储方式 | 关联字段 | 匹配方式 |
|------|------------|---------|---------|
| 子系统模板 | 引用基础物料库 | `materialId` | 通过 ID 匹配 |
| 设备系统模板 | 复制基础物料数据 | 无外键，只有 `materialCode` | 通过编码匹配 |

### 2. 为什么设备系统模板使用复制而不是引用？

1. **数据独立性**：设备系统模板需要独立的物料数据，不受基础物料库变更的影响
2. **版本控制**：每个设备系统模板可以有自己的物料版本
3. **灵活性**：可以在模板中修改物料属性，不影响基础物料库

### 3. materialCode 的重要性

- `materialCode` 是物料的唯一标识符（业务编码）
- 在复制物料时，`materialCode` 会被保留
- 通过 `materialCode` 可以追溯物料的来源
- 用于前端去重和匹配已添加的物料

## 版本历史

| 版本 | 日期 | 修改内容 |
|------|------|---------|
| 1.0 | 2025-11-13 | 初始版本，修复子系统模板的自动勾选问题 |
| 1.1 | 2025-11-19 | 修复设备系统模板的 NaN 问题，支持编码匹配 |

