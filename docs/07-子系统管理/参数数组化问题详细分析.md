# 参数数组化问题详细分析

## 问题现象

**错误的传参格式**：

```json
{
  "templateId": ["1985928480973324290"]  // ❌ 数组格式
}
```

**正确的传参格式**：

```json
{
  "templateId": "1985928480973324290"    // ✅ 单个字符串
}
```

---

## 问题根因分析

### 1. axios 拦截器处理流程

**文件**：`src/utils/request.ts` (第 58-64 行)

```typescript
// get请求映射params参数
if (config.method === 'get' && config.params) {
  let url = config.url + '?' + tansParams(config.params);
  url = url.slice(0, -1);
  config.params = {};
  config.url = url;
}
```

**流程**：

1. 检测到 GET 请求且有 `params` 对象
2. 调用 `tansParams` 函数将 `params` 转换为 URL 查询字符串
3. 清空 `params` 对象，将完整 URL 赋值给 `config.url`

---

### 2. tansParams 函数实现

**文件**：`src/utils/ruoyi.ts` (第 210-230 行)

```typescript
export const tansParams = (params: any) => {
  let result = '';
  for (const propName of Object.keys(params)) {
    const value = params[propName];
    const part = encodeURIComponent(propName) + '=';
    if (value !== null && value !== '' && typeof value !== 'undefined') {
      if (typeof value === 'object') {  // ⚠️ 关键判断
        // 如果值是对象，使用 propName[key] 格式
        for (const key of Object.keys(value)) {
          if (value[key] !== null && value[key] !== '' && typeof value[key] !== 'undefined') {
            const params = propName + '[' + key + ']';  // ⚠️ 产生数组格式
            const subPart = encodeURIComponent(params) + '=';
            result += subPart + encodeURIComponent(value[key]) + '&';
          }
        }
      } else {
        result += part + encodeURIComponent(value) + '&';
      }
    }
  }
  return result;
};
```

**问题点**：

- 第 216 行：`if (typeof value === 'object')`
- 如果 `templateId` 的值是对象类型（包括数组），就会进入对象处理分支
- 第 219 行：`propName + '[' + key + ']'` 会产生类似 `templateId[0]` 的格式

---

### 3. 为什么 templateId 会变成对象？

#### 可能原因 1：ID 转换器的影响

**文件**：`src/utils/request.ts` (第 54-56 行)

```typescript
if (config.params) {
  config.params = convertRequestIds(config.params);
}
```

**ID 转换器逻辑**：`src/utils/id-converter.ts`

```typescript
export function convertRequestIds(data: any): any {
  if (!data || typeof data !== 'object') {
    return data;
  }
  return convertIdsToString(data);
}

export function convertIdsToString(obj: any): any {
  // 数组：递归处理每个元素
  if (Array.isArray(obj)) {
    return obj.map(item => convertIdsToString(item));
  }

  // 处理普通对象
  const result: any = {};
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      const value = obj[key];

      // 如果是ID字段，转换值
      if (isIdField(key)) {
        result[key] = convertIdValue(value);  // ⚠️ 转换为字符串
      }
      // ...
    }
  }
  return result;
}
```

**分析**：

- `convertRequestIds` 会递归处理对象，将 ID 字段转换为字符串
- 但是它**不会将对象类型的值转换为基本类型**
- 如果传入的 `params` 本身结构有问题，转换后还是有问题

---

#### 可能原因 2：params 对象构造错误

**错误的构造方式**：

```typescript
// ❌ 错误方式1：直接传递数组
params: { templateId: [templateId] }

// ❌ 错误方式2：使用URLSearchParams时重复添加
const params = new URLSearchParams();
params.append('templateId', templateId);
params.append('templateId', templateId);  // 重复添加会变成数组

// ❌ 错误方式3：某些中间件或拦截器错误处理
```

**正确的构造方式**：

```typescript
// ✅ 正确方式1：直接传递值
params: { templateId: templateId }

// ✅ 正确方式2：条件传递
params: templateId ? { templateId } : {}

// ✅ 正确方式3：使用URLSearchParams.set()
const params = new URLSearchParams();
params.set('templateId', String(templateId));  // 使用set而不是append
```

---

## 我的修复方案

### 方案：直接构造 URL，绕过 params 对象

**文件**：`src/api/erp/subsystem/material-template.ts`

```typescript
export const listMaterialTemplateByItemId = (
  itemTemplateId: string | number,
  templateId?: string | number
): AxiosPromise<SubsystemMaterialTemplateVO[]> => {
  // ✅ 修复：直接构造URL，避免params对象序列化导致的数组问题
  let url = `/erp/subsystem/material-template/list-by-item/${itemTemplateId}`;
  if (templateId) {
    // 确保templateId作为单个字符串值传递
    url += `?templateId=${encodeURIComponent(String(templateId))}`;
  }

  return request({
    url: url,
    method: 'get'
    // ⚠️ 注意：不传递 params 对象
  });
};
```

**修复原理**：

1. **跳过 params 对象**：

   - 不使用 `params: { templateId }`
   - 直接在 URL 中拼接查询参数

2. **绕过拦截器处理**：

   - axios 拦截器第 58 行：`if (config.method === 'get' && config.params)`
   - 因为没有 `config.params`，不会执行 `tansParams` 函数
   - 避免了可能的对象转数组问题

3. **确保类型正确**：

   - 使用 `String(templateId)` 确保转换为字符串
   - 使用 `encodeURIComponent()` 处理特殊字符

4. **最终 URL 格式**：
   ```
   /erp/subsystem/material-template/list-by-item/1986239297161666561?templateId=1985928480973324290
   ```

---

## 为什么这个方案有效

### 对比分析

#### 原方案（有问题）

```typescript
return request({
  url: `/erp/subsystem/material-template/list-by-item/${itemTemplateId}`,
  method: 'get',
  params: templateId ? { templateId } : {}  // ⚠️ 使用params对象
});
```

**执行流程**：

1. axios 发送请求
2. 请求拦截器处理：
   ```typescript
   config.params = convertRequestIds(config.params);  // ID转换
   ```
3. GET 请求特殊处理：
   ```typescript
   let url = config.url + '?' + tansParams(config.params);  // ⚠️ 可能产生数组格式
   ```
4. 如果在某个环节 `templateId` 变成了对象或数组，就会产生错误格式

---

#### 新方案（正确）

```typescript
let url = `/erp/subsystem/material-template/list-by-item/${itemTemplateId}`;
if (templateId) {
  url += `?templateId=${encodeURIComponent(String(templateId))}`;
}

return request({
  url: url,
  method: 'get'
  // ⚠️ 不传递 params
});
```

**执行流程**：

1. 在 API 函数中直接构造完整 URL
2. axios 发送请求
3. 请求拦截器处理：
   ```typescript
   if (config.params) {  // ⚠️ config.params 为 undefined，跳过
     config.params = convertRequestIds(config.params);
   }
   ```
4. GET 请求特殊处理：
   ```typescript
   if (config.method === 'get' && config.params) {  // ⚠️ config.params 为 undefined，跳过
     // ...
   }
   ```
5. 直接使用构造好的 URL 发送请求

**优势**：

- ✅ 完全绕过可能导致数组化的处理逻辑
- ✅ URL 格式完全可控
- ✅ 类型转换在函数内部完成，更加可靠
- ✅ 避免了各种中间件或拦截器的干扰

---

## 后端接收验证

### 修复前

**请求**：

```
GET /erp/subsystem/material-template/list-by-item/xxx
```

**后端日志**：

```log
参数类型[param],参数:[{"templateId":["1985928480973324290"]}]  // ❌ 数组格式
Execute SQL：WHERE item_template_id = xxx  // ❌ 缺少 template_id 条件
```

**后端接收**：

```java
@RequestParam(required = false) Long templateId
// templateId = null  ❌ 无法从数组转换为Long
```

---

### 修复后

**请求**：

```
GET /erp/subsystem/material-template/list-by-item/xxx?templateId=1985928480973324290
```

**后端日志**：

```log
参数类型[param],参数:[{"templateId":"1985928480973324290"}]  // ✅ 单个字符串
Execute SQL：WHERE item_template_id = xxx AND template_id = 1985928480973324290  // ✅ 包含条件
```

**后端接收**：

```java
@RequestParam(required = false) Long templateId
// templateId = 1985928480973324290L  ✅ 正确转换
```

---

## 总结

### 问题根源

1. ❌ axios 的 `params` 对象可能被某些处理逻辑错误地转换为数组格式
2. ❌ `tansParams` 函数对对象类型的值使用 `propName[key]` 格式
3. ❌ 后端 Spring Boot 无法将数组转换为单个 Long 值

### 解决方案

✅ **直接在 URL 中拼接查询参数，完全绕过 `params` 对象的序列化过程**

### 修复效果

1. ✅ 确保 `templateId` 作为单个字符串值传递
2. ✅ 避免了数组化问题
3. ✅ 后端能够正确接收参数
4. ✅ SQL 查询包含 `template_id` 条件
5. ✅ 实现了数据隔离

---

**文档创建时间**：2025-11-06  
**问题状态**：✅ 已修复  
**修复方式**：直接构造 URL，绕过 params 对象

