# 物料同步到子项模板问题分析

## 问题描述

**用户反馈**：在子系统管理 > 子项管理 > 物料管理页面操作物料时，数据还是同步到了子项模板，应该是后台接口问题。

**预期行为**：在子系统中修改物料时，只修改子系统的物料记录（`template_id` = 子系统ID），不应该影响子项模板的物料记录（`template_id` = NULL）。

---

## 前端代码验证

### 1. 新增物料（✅ 前端正确）

**文件**：`src/views/erp/subsystem/template/components/ItemTemplateManagement.vue` (第520-527行)

```typescript
const materialTemplates: SubsystemMaterialTemplateForm[] = materials.map(material => ({
  templateId: props.templateId,  // ✅ 正确传递子系统ID
  itemTemplateId: selectedItemId.value!,
  materialId: material.id as number,
  defaultQuantity: 1,
  isRequired: true,
  remarks: ''
}));
```

**验证**：✅ 前端已正确传递 `templateId` 字段

---

### 2. 编辑物料（✅ 前端正确）

**文件**：`src/views/erp/subsystem/template/components/ItemTemplateManagement.vue` (第539-543行)

```typescript
const handleEditMaterial = (row: SubsystemMaterialTemplateVO) => {
  resetMaterialForm();
  Object.assign(materialForm, row);  // ✅ 保留所有字段包括 templateId
  materialEditDialog.visible = true;
};
```

**提交更新** (第571行)：
```typescript
await updateMaterialTemplate(materialForm);  // ✅ 包含完整的 templateId
```

**验证**：✅ 前端已正确保留 `templateId` 字段

---

### 3. 删除物料（✅ 前端正确）

**文件**：`src/views/erp/subsystem/template/components/ItemTemplateManagement.vue` (第554行)

```typescript
await delMaterialTemplate(row.id);  // ✅ 通过唯一ID删除
```

**验证**：✅ 前端通过记录ID精确删除

---

## 后端接口分析

根据文档 `docs/07-子系统管理/子系统模板子项和物料管理API文档.md` 第725-783行：

### 物料自动同步机制

**同步触发场景**：

1. **添加子项到模板时**：自动同步子项的物料到子系统物料表
   ```
   查询：template_id = NULL AND item_template_id = XXX（子项模板的物料）
   复制：template_id = 子系统ID, item_template_id = XXX
   ```

2. **移除子项从模板时**：自动清理该子项在子系统中的物料
   ```
   删除：template_id = 子系统ID AND item_template_id = XXX
   ```

---

## 问题根因推测

### 可能原因 1：反向同步问题

**问题**：后端在处理子系统物料的增删改时，可能错误地也更新了子项模板的物料。

**排查点**：
- 检查物料新增/编辑/删除接口，是否有错误的反向同步逻辑
- 检查是否同时更新了 `template_id = NULL` 的记录

**后端代码位置**（推测）：
```java
// 可能的错误实现
// ErpSubsystemMaterialTemplateServiceImpl.java

// ❌ 错误：同时更新了子项模板的物料
public void updateMaterialTemplate(ErpSubsystemMaterialTemplateForm form) {
    // 更新子系统的物料记录
    baseMapper.updateById(form);
    
    // ❌ 错误：还更新了子项模板的物料
    LambdaUpdateWrapper<ErpSubsystemMaterialTemplate> wrapper = new LambdaUpdateWrapper<>();
    wrapper.eq(ErpSubsystemMaterialTemplate::getItemTemplateId, form.getItemTemplateId())
           .eq(ErpSubsystemMaterialTemplate::getMaterialId, form.getMaterialId())
           .isNull(ErpSubsystemMaterialTemplate::getTemplateId);  // ❌ 影响到子项模板
    baseMapper.update(form, wrapper);
}
```

---

### 可能原因 2：查询条件错误

**问题**：后端在更新/删除物料时，查询条件只使用了 `item_template_id` + `material_id`，没有加上 `template_id` 条件。

**错误示例**：
```java
// ❌ 错误的查询条件
LambdaUpdateWrapper<ErpSubsystemMaterialTemplate> wrapper = new LambdaUpdateWrapper<>();
wrapper.eq(ErpSubsystemMaterialTemplate::getItemTemplateId, itemTemplateId)
       .eq(ErpSubsystemMaterialTemplate::getMaterialId, materialId);
// 缺少：.eq(ErpSubsystemMaterialTemplate::getTemplateId, templateId)

// 这会导致：同时更新了所有子系统（包括template_id=NULL的记录）的物料
```

**正确示例**：
```java
// ✅ 正确的查询条件
LambdaUpdateWrapper<ErpSubsystemMaterialTemplate> wrapper = new LambdaUpdateWrapper<>();
wrapper.eq(ErpSubsystemMaterialTemplate::getItemTemplateId, itemTemplateId)
       .eq(ErpSubsystemMaterialTemplate::getMaterialId, materialId)
       .eq(ErpSubsystemMaterialTemplate::getTemplateId, templateId);  // ✅ 必须加上
```

---

### 可能原因 3：批量操作问题

**问题**：批量新增物料时，可能错误地创建了多条记录（包括 `template_id = NULL` 的记录）。

**错误示例**：
```java
// ❌ 错误：批量新增时创建了两条记录
public void addMaterialTemplateBatch(List<ErpSubsystemMaterialTemplateForm> forms) {
    for (ErpSubsystemMaterialTemplateForm form : forms) {
        // 1. 创建子系统的物料记录
        baseMapper.insert(form);
        
        // 2. ❌ 错误：还创建了子项模板的物料记录
        ErpSubsystemMaterialTemplate itemMaterial = new ErpSubsystemMaterialTemplate();
        itemMaterial.setTemplateId(null);  // ❌ 子项模板物料
        itemMaterial.setItemTemplateId(form.getItemTemplateId());
        itemMaterial.setMaterialId(form.getMaterialId());
        // ...
        baseMapper.insert(itemMaterial);
    }
}
```

---

## 数据验证方法

### 1. 数据库查询验证

**查询子系统的物料记录**：
```sql
SELECT id, template_id, item_template_id, material_id, default_quantity
FROM erp_subsystem_material_template
WHERE item_template_id = 1986239297161666561  -- 替换为实际的子项ID
ORDER BY template_id, create_time DESC;
```

**预期结果**：
```
id  | template_id          | item_template_id        | material_id        | default_quantity
----|----------------------|-------------------------|--------------------|-----------------
1   | 1985928480973324290  | 1986239297161666561     | 物料ID1            | 10
2   | NULL                 | 1986239297161666561     | 物料ID1            | 5   ← 子项模板物料
```

**问题验证**：
- ✅ 如果 `template_id = NULL` 的记录没有被修改，说明没有同步问题
- ❌ 如果 `template_id = NULL` 的记录也被修改了，说明存在同步问题

---

### 2. 前端请求验证

**步骤**：
1. 打开浏览器开发者工具（F12）
2. 切换到 Network 标签
3. 在子系统页面添加/编辑物料
4. 查看请求的 Payload

**预期的请求体**：
```json
{
  "id": 1,  // 编辑时有ID
  "templateId": 1985928480973324290,  // ✅ 必须有子系统ID
  "itemTemplateId": 1986239297161666561,
  "materialId": 1985570850991910913,
  "defaultQuantity": 10,
  "isRequired": true,
  "remarks": ""
}
```

**验证点**：
- ✅ 确认请求体包含 `templateId` 字段
- ✅ 确认 `templateId` 的值是当前子系统的ID，不是 NULL

---

### 3. 后端日志验证

**建议在后端添加日志**：

```java
// ErpSubsystemMaterialTemplateServiceImpl.java

@Override
public void addMaterialTemplate(ErpSubsystemMaterialTemplateForm form) {
    log.info("新增物料模板，templateId={}, itemTemplateId={}, materialId={}", 
             form.getTemplateId(), form.getItemTemplateId(), form.getMaterialId());
    
    // 验证 templateId 是否正确
    if (form.getTemplateId() == null) {
        log.warn("警告：templateId 为空，可能是前端未传递或后端逻辑错误");
    }
    
    // 执行新增
    baseMapper.insert(BeanUtil.toBean(form, ErpSubsystemMaterialTemplate.class));
    
    // 验证是否错误地创建了多条记录
    long count = baseMapper.selectCount(new LambdaQueryWrapper<ErpSubsystemMaterialTemplate>()
        .eq(ErpSubsystemMaterialTemplate::getItemTemplateId, form.getItemTemplateId())
        .eq(ErpSubsystemMaterialTemplate::getMaterialId, form.getMaterialId()));
    
    if (count > 1) {
        log.error("错误：同一子项的同一物料存在多条记录，count={}", count);
    }
}
```

---

## 修复建议

### 1. 检查物料新增接口

**接口**：`POST /erp/subsystem/material-template` 或 `POST /erp/subsystem/material-template/batch`

**检查点**：
- ✅ 确认只创建一条记录（`template_id` = 子系统ID）
- ❌ 不要创建多条记录（包括 `template_id = NULL` 的记录）

**正确实现**：
```java
@Override
public void addMaterialTemplate(ErpSubsystemMaterialTemplateForm form) {
    // ✅ 只创建一条记录
    ErpSubsystemMaterialTemplate entity = BeanUtil.toBean(form, ErpSubsystemMaterialTemplate.class);
    entity.setTemplateId(form.getTemplateId());  // ✅ 使用前端传递的 templateId
    baseMapper.insert(entity);
    
    // ❌ 不要创建子项模板的物料记录
}
```

---

### 2. 检查物料编辑接口

**接口**：`PUT /erp/subsystem/material-template`

**检查点**：
- ✅ 只更新指定ID的记录
- ❌ 不要通过 `item_template_id` + `material_id` 批量更新

**正确实现**：
```java
@Override
public void updateMaterialTemplate(ErpSubsystemMaterialTemplateForm form) {
    // ✅ 只通过ID更新
    ErpSubsystemMaterialTemplate entity = BeanUtil.toBean(form, ErpSubsystemMaterialTemplate.class);
    baseMapper.updateById(entity);
    
    // ❌ 不要使用以下方式（会影响到其他记录）
    // LambdaUpdateWrapper<ErpSubsystemMaterialTemplate> wrapper = new LambdaUpdateWrapper<>();
    // wrapper.eq(ErpSubsystemMaterialTemplate::getItemTemplateId, form.getItemTemplateId())
    //        .eq(ErpSubsystemMaterialTemplate::getMaterialId, form.getMaterialId());
    // baseMapper.update(entity, wrapper);
}
```

---

### 3. 检查物料删除接口

**接口**：`DELETE /erp/subsystem/material-template/{ids}`

**检查点**：
- ✅ 只删除指定ID的记录
- ❌ 不要通过 `item_template_id` + `material_id` 批量删除

**正确实现**：
```java
@Override
public void deleteMaterialTemplate(String ids) {
    // ✅ 只通过ID删除
    List<Long> idList = Arrays.stream(ids.split(","))
        .map(Long::parseLong)
        .collect(Collectors.toList());
    baseMapper.deleteBatchIds(idList);
    
    // ❌ 不要使用以下方式（会影响到其他记录）
    // LambdaQueryWrapper<ErpSubsystemMaterialTemplate> wrapper = new LambdaQueryWrapper<>();
    // wrapper.eq(ErpSubsystemMaterialTemplate::getItemTemplateId, itemTemplateId)
    //        .eq(ErpSubsystemMaterialTemplate::getMaterialId, materialId);
    // baseMapper.delete(wrapper);
}
```

---

### 4. 检查是否有反向同步逻辑

**搜索关键词**：
```bash
# 在后端代码中搜索
grep -r "template_id.*null" --include="*.java"
grep -r "isNull.*template" --include="*.java"
grep -r "同步.*子项" --include="*.java"
```

**检查点**：
- ✅ 确认没有反向同步逻辑（从子系统物料同步回子项模板物料）
- ✅ 确认只有正向同步（从子项模板物料同步到子系统物料，且只在添加子项时触发）

---

## 数据隔离原则

### 正确的数据模型

```
erp_subsystem_material_template 表：

记录1：子项模板的默认物料（独立存在）
- template_id: NULL
- item_template_id: 10
- material_id: 100
- default_quantity: 5

记录2：子系统A中子项的物料（关联到子系统A）
- template_id: 1  ← 子系统A的ID
- item_template_id: 10
- material_id: 100
- default_quantity: 10  ← 可以与记录1不同

记录3：子系统B中子项的物料（关联到子系统B）
- template_id: 2  ← 子系统B的ID
- item_template_id: 10
- material_id: 100
- default_quantity: 15  ← 可以与记录1、记录2都不同
```

### 数据操作原则

**在子系统管理页面**：
- ✅ 只操作 `template_id = 当前子系统ID` 的记录
- ❌ 不应该操作 `template_id = NULL` 的记录
- ❌ 不应该操作其他子系统的记录

**在子项模板管理页面**：
- ✅ 只操作 `template_id = NULL` 的记录
- ❌ 不应该操作任何子系统的记录

---

## 测试用例

### 测试用例1：新增物料不同步

**步骤**：
1. 查询子项A的默认物料：`SELECT * FROM erp_subsystem_material_template WHERE item_template_id=A AND template_id IS NULL`
2. 在子系统X中为子项A添加物料M1（数量10）
3. 再次查询子项A的默认物料

**预期结果**：
- ✅ 子项A的默认物料没有变化
- ✅ 只新增了 `template_id=X` 的记录

---

### 测试用例2：编辑物料不同步

**准备数据**：
- 子项A的默认物料M1（`template_id=NULL`，数量=5）
- 子系统X中子项A的物料M1（`template_id=X`，数量=10）

**步骤**：
1. 在子系统X中将物料M1的数量修改为20
2. 查询子项A的默认物料M1

**预期结果**：
- ✅ 子项A的默认物料M1数量仍然是5
- ✅ 只更新了 `template_id=X` 的记录

---

### 测试用例3：删除物料不同步

**准备数据**：
- 子项A的默认物料M1（`template_id=NULL`）
- 子系统X中子项A的物料M1（`template_id=X`）

**步骤**：
1. 在子系统X中删除物料M1
2. 查询子项A的默认物料M1

**预期结果**：
- ✅ 子项A的默认物料M1仍然存在
- ✅ 只删除了 `template_id=X` 的记录

---

## 总结

### 问题定位

**前端代码**：✅ 已验证正确，正确传递了 `templateId` 字段

**后端接口**：❌ 可能存在以下问题：
1. 错误地同时更新了子项模板的物料（`template_id = NULL`）
2. 查询条件缺少 `template_id` 限制
3. 批量操作时创建了多条记录

### 修复方向

1. **检查后端接口实现**：确保只操作当前子系统的物料记录
2. **添加数据验证**：确认 `templateId` 字段不为空
3. **添加日志**：记录物料操作，便于排查
4. **修改查询条件**：所有物料操作都必须带上 `template_id` 条件

### 后续建议

1. **后端开发人员**：检查物料增删改接口的实现，参考本文档的修复建议
2. **测试人员**：使用本文档的测试用例验证修复效果
3. **数据库管理**：检查现有数据是否有异常（多条重复记录、数据不一致等）

---

**文档创建时间**：2025-11-06  
**问题状态**：待后端修复

