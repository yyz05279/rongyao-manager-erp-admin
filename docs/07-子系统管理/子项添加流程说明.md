# 子项添加流程说明

## 问题描述

用户反馈：**子系统添加已存在的子项模版时，还是新建了子项模版**

## 根本原因

前端在添加已存在的子项时，调用了**错误的接口**或**传递了错误的参数**。

## 正确的 API 调用流程

### 场景 1：添加已存在的子项到模板（推荐）

**接口**: `POST /erp/subsystem/template/{templateId}/items`

**用途**: 将已经存在的子项模板关联到子系统模板

**请求参数**:

```json
{
    "itemTemplateId": 10, // ✅ 必须传递已存在子项的ID
    "quantity": 1,
    "sequenceNumber": 10,
    "isRequired": true,
    "remarks": "核心组件"
}
```

**特点**:

-   ✅ **不会创建新子项**，只建立关联关系
-   ✅ 自动同步子项的物料到子系统
-   ✅ 这是添加已存在子项的**标准接口**

---

### 场景 2：创建新子项并自动关联到模板

**接口**: `POST /erp/subsystem/item-template`

**用途**: 创建一个全新的子项模板，并可选地关联到模板

**请求参数**:

```json
{
    "templateId": 1, // 可选：提供则自动关联到模板
    "itemName": "新子项", // 必填：子项名称
    "itemType": "组件",
    "specification": "标准型",
    "defaultQuantity": 1,
    "unit": "个",
    "isRequired": true
}
```

**特点**:

-   ✅ **会创建新子项**
-   ⚠️ 如果只是想添加已存在的子项，**不应该使用这个接口**

---

### 场景 3：创建新子项并关联（使用智能判断）

**接口**: `POST /erp/subsystem/item-template`

**用途**: 利用后端的智能判断，自动识别是创建还是关联

**请求参数（关联已存在子项）**:

```json
{
    "id": 10, // ✅ 传递已存在子项的ID
    "templateId": 1 // 模板ID
}
```

或者：

```json
{
    "itemCode": "ITEM-00001", // ✅ 传递已存在子项的编号
    "templateId": 1 // 模板ID
}
```

**智能判断逻辑**:

1. 如果传递了 `id` → 使用已存在的子项（不创建新子项）
2. 如果传递了 `itemCode` 且该编号已存在 → 使用已存在的子项
3. 如果都没有传 或 `itemCode` 不存在 → 创建新子项

---

## 前端修改建议

### 当前问题

前端在选择已存在的子项时，可能：

1. 调用了 `POST /erp/subsystem/item-template` 接口
2. 但是**没有传递** `id` 或 `itemCode` 参数
3. 导致后端判断为"创建新子项"

### 解决方案

#### 方案 1：使用正确的接口（推荐）✅

前端逻辑：

```javascript
// 判断是创建新子项还是添加已存在子项
if (isAddExisting) {
    // 添加已存在的子项
    await addItemToTemplate(templateId, {
        itemTemplateId: selectedItem.id, // 已选择子项的ID
        quantity: 1,
        isRequired: true,
    });
} else {
    // 创建新子项
    await createItemTemplate({
        templateId: templateId,
        itemName: "新子项名称",
        itemType: "组件",
        // ... 其他字段
    });
}
```

API 调用：

```javascript
// 添加已存在的子项
async function addItemToTemplate(templateId, data) {
    return request({
        url: `/erp/subsystem/template/${templateId}/items`,
        method: "post",
        data: data,
    });
}

// 创建新子项
async function createItemTemplate(data) {
    return request({
        url: "/erp/subsystem/item-template",
        method: "post",
        data: data,
    });
}
```

---

#### 方案 2：使用智能判断（次选）

如果前端只想调用一个接口，可以传递 `id` 参数：

```javascript
// 选择已存在的子项
const data = {
    id: selectedItem.id, // ✅ 传递已存在子项的ID
    templateId: templateId,
};

// 或者传递子项编号
const data = {
    itemCode: selectedItem.itemCode, // ✅ 传递已存在子项的编号
    templateId: templateId,
};

await createItemTemplate(data);
```

**注意**: 这个方案虽然可行，但不如方案 1 清晰明确。

---

## 测试验证

### 测试 1：添加已存在的子项（正确流程）

**步骤**:

1. 查询子项列表，获取一个已存在子项的 ID（如：10）
2. 调用接口：`POST /erp/subsystem/template/1/items`
3. 请求体：

```json
{
    "itemTemplateId": 10,
    "quantity": 1
}
```

**预期结果**:

-   ✅ 不会创建新子项
-   ✅ 在 `erp_subsystem_template_item_rel` 表中创建关联记录
-   ✅ 子项的物料自动同步到 `erp_subsystem_material_template` 表

---

### 测试 2：使用智能判断添加已存在子项

**步骤**:

1. 查询子项列表，获取一个已存在子项的 ID（如：10）
2. 调用接口：`POST /erp/subsystem/item-template`
3. 请求体：

```json
{
    "id": 10,
    "templateId": 1
}
```

**预期结果**:

-   ✅ 不会创建新子项
-   ✅ 日志显示："检测到子项 ID[10]，使用已存在的子项：xxx"
-   ✅ 子项被关联到模板

---

### 测试 3：错误的调用方式（会创建新子项）❌

**步骤**:

1. 选择一个已存在的子项（ID：10，itemCode：ITEM-00001）
2. 调用接口：`POST /erp/subsystem/item-template`
3. 请求体：

```json
{
    "itemName": "输送带", // ❌ 没有传递id或itemCode
    "templateId": 1,
    "itemType": "组件"
}
```

**结果**:

-   ❌ **会创建一个新的子项**（因为没有 id 或 itemCode）
-   ❌ 新子项会有新的 ID 和编号（如：ITEM-00003）
-   ❌ 这是当前的问题所在！

---

## 总结

1. **推荐方案**: 前端区分两种场景，调用对应的接口

    - 添加已存在子项 → `POST /erp/subsystem/template/{templateId}/items`
    - 创建新子项 → `POST /erp/subsystem/item-template`

2. **备选方案**: 统一使用 `POST /erp/subsystem/item-template`，但**必须传递** `id` 或 `itemCode` 参数

3. **当前问题**: 前端在选择已存在子项时，没有传递 `id` 或 `itemCode`，导致后端创建新子项

---

## 修复记录

-   **修复时间**: 2025-11-06
-   **修复内容**: 在后端 `insertByBo` 方法中添加了智能判断逻辑，可以根据 `id` 或 `itemCode` 自动识别是否使用已存在子项
-   **前端需要**: 传递正确的参数（`id` 或 `itemCode`）或使用正确的接口
