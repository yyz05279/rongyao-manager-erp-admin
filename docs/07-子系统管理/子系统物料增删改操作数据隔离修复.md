# 子系统物料增删改操作数据隔离修复

## 修复概述

本次修复确保子系统中子项的物料增删改操作遵循数据隔离原则，不同子系统中同一子项的物料配置完全独立，互不影响。

## 问题背景

根据 [子系统物料独立管理功能修复.md](./子系统物料独立管理功能修复.md) 和 [子系统物料查询API使用指南.md](./子系统物料查询API使用指南.md) 的说明，后端查询接口已经支持通过 `templateId` 参数实现数据隔离。

**核心原则**：
- 通过 `template_id` + `item_template_id` 组合来唯一标识一个子系统中的子项物料配置
- 不同子系统中同一子项的物料配置应该完全独立
- 修改一个子系统的物料不应该影响其他子系统

## 修复内容

### 1. API 接口修改

**文件**：`src/api/erp/subsystem/material-template.ts`

**修改内容**：为 `listMaterialTemplateByItemId` 接口增加可选的 `templateId` 参数

```typescript
/**
 * 根据子项ID查询物料列表
 * 说明：查询指定子项模板下配置的所有物料
 * @param itemTemplateId 子项模板ID
 * @param templateId 子系统模板ID（可选，传递时只查询该子系统中该子项的物料，不传则查询所有子系统中该子项的物料）
 * @returns 物料列表
 */
export const listMaterialTemplateByItemId = (
  itemTemplateId: string | number,
  templateId?: string | number
): AxiosPromise<SubsystemMaterialTemplateVO[]> => {
  return request({
    url: `/erp/subsystem/material-template/list-by-item/${itemTemplateId}`,
    method: 'get',
    params: templateId ? { templateId } : {}
  });
};
```

**改进点**：
- ✅ 支持传递可选的 `templateId` 参数
- ✅ 当传递 `templateId` 时，只查询该子系统中的物料（数据隔离）
- ✅ 当不传递 `templateId` 时，查询所有子系统中的物料（向后兼容）

### 2. 前端组件修改

**文件**：`src/views/erp/subsystem/template/components/ItemTemplateManagement.vue`

**修改位置**：`loadMaterialList` 方法

#### 修改前

```typescript
// 加载物料列表
const loadMaterialList = async () => {
  if (!selectedItemId.value) return;

  materialLoading.value = true;
  try {
    // ❌ 问题：没有传递 templateId，会查询所有子系统的物料
    const response = await listMaterialTemplateByItemId(selectedItemId.value);

    // ❌ 需要前端手动过滤，容易出错
    const allMaterials = response.data || [];
    materialList.value = allMaterials.filter(
      (material: SubsystemMaterialTemplateVO) =>
        Number(material.templateId) === Number(props.templateId) &&
        Number(material.itemTemplateId) === Number(selectedItemId.value)
    );
  } catch (error) {
    console.error('加载物料列表失败:', error);
    ElMessage.error('加载物料列表失败');
  } finally {
    materialLoading.value = false;
  }
};
```

#### 修改后

```typescript
// 加载物料列表
const loadMaterialList = async () => {
  if (!selectedItemId.value) return;

  materialLoading.value = true;
  try {
    // ✅ 修复：传递 templateId 参数，实现数据隔离
    // 只查询当前子系统中该子项的物料，不查询其他子系统的物料
    const response = await listMaterialTemplateByItemId(
      selectedItemId.value,
      props.templateId // ✅ 传递子系统模板ID，确保数据隔离
    );

    // ✅ 后端已经按照 templateId 过滤，直接使用返回的数据
    materialList.value = response.data || [];
  } catch (error) {
    console.error('加载物料列表失败:', error);
    ElMessage.error('加载物料列表失败');
  } finally {
    materialLoading.value = false;
  }
};
```

**改进点**：
- ✅ 传递 `templateId` 参数，后端直接过滤数据
- ✅ 移除前端手动过滤逻辑，避免错误
- ✅ 代码更简洁，性能更好

## 增删改操作验证

### 1. 查询操作 ✅

**场景**：在子系统管理页面查看子项的物料列表

**实现**：`loadMaterialList` 方法

```typescript
const response = await listMaterialTemplateByItemId(
  selectedItemId.value,
  props.templateId // ✅ 传递子系统ID
);
```

**结果**：只查询当前子系统中该子项的物料，数据隔离

---

### 2. 新增操作 ✅

**场景**：在子系统管理页面为子项添加物料

**实现**：`handleMaterialsSelected` 方法（第520-527行）

```typescript
const materialTemplates: SubsystemMaterialTemplateForm[] = materials.map(material => ({
  templateId: props.templateId,  // ✅ 正确传递子系统ID
  itemTemplateId: selectedItemId.value!,
  materialId: material.id as number,
  defaultQuantity: 1,
  isRequired: true,
  remarks: ''
}));

await addMaterialTemplateBatch(materialTemplates);
```

**验证**：
- ✅ `templateId` 字段正确设置为 `props.templateId`
- ✅ 新增的物料记录会关联到当前子系统
- ✅ 不会影响其他子系统

---

### 3. 编辑操作 ✅

**场景**：在子系统管理页面修改子项的物料配置

**实现**：`handleEditMaterial` 方法（第539-543行）

```typescript
const handleEditMaterial = (row: SubsystemMaterialTemplateVO) => {
  resetMaterialForm();
  Object.assign(materialForm, row);  // ✅ 复制所有字段，包括 templateId
  materialEditDialog.visible = true;
};
```

**提交更新**：`submitMaterialEditForm` 方法（第568-586行）

```typescript
await updateMaterialTemplate(materialForm);  // ✅ 保持原有的 templateId
```

**验证**：
- ✅ 编辑时保留原有的 `templateId` 字段
- ✅ 更新操作不会改变物料的归属关系
- ✅ 不会影响其他子系统的物料

---

### 4. 删除操作 ✅

**场景**：在子系统管理页面删除子项的物料

**实现**：`handleDeleteMaterial` 方法（第545-564行）

```typescript
await delMaterialTemplate(row.id);  // ✅ 直接删除指定ID的物料记录
```

**验证**：
- ✅ 删除操作通过物料记录的唯一ID进行
- ✅ 只删除当前子系统中的物料记录
- ✅ 不会影响其他子系统的物料

---

## 不同场景的使用对比

### 场景1：子系统管理页面（需要数据隔离）

**文件**：`src/views/erp/subsystem/template/components/ItemTemplateManagement.vue`

**特点**：
- ✅ 查询时传递 `templateId` 参数
- ✅ 新增时设置 `templateId` 字段
- ✅ 编辑时保持 `templateId` 不变
- ✅ 删除时通过记录ID精确删除

**查询调用**：
```typescript
await listMaterialTemplateByItemId(selectedItemId.value, props.templateId);
```

**新增调用**：
```typescript
{
  templateId: props.templateId,  // ✅ 关联到子系统
  itemTemplateId: selectedItemId.value,
  materialId: material.id,
  // ...
}
```

---

### 场景2：子项模板独立管理页面（不需要数据隔离）

**文件**：`src/views/erp/subsystem/item-template/index.vue`

**特点**：
- ✅ 查询时不传递 `templateId` 参数（查询所有子系统中的物料）
- ✅ 新增时不设置 `templateId` 字段（创建独立物料）
- ✅ 这是独立子项模板的管理页面，不属于特定子系统

**查询调用**：
```typescript
await listMaterialTemplateByItemId(materialDialog.itemId);
// ✅ 不传递 templateId，查询该子项在所有子系统中的物料
```

**新增调用**：
```typescript
{
  // ✅ 不传递 templateId，创建独立物料（template_id = NULL）
  itemTemplateId: materialDialog.itemId,
  materialId: material.id,
  // ...
}
```

---

## 数据隔离原理

### 数据库层面

物料记录通过以下字段组合实现隔离：

| 字段             | 说明           | 作用                     |
| ---------------- | -------------- | ------------------------ |
| `template_id`    | 子系统模板ID   | 区分不同子系统           |
| `item_template_id` | 子项模板ID   | 标识子项                 |
| `material_id`    | 物料ID         | 标识物料                 |

**唯一标识**：`template_id` + `item_template_id` + `material_id`

### 查询条件对比

#### 修改前（数据混淆）

```sql
SELECT * FROM erp_subsystem_material_template
WHERE item_template_id = ?
ORDER BY create_time DESC
```

**问题**：查询到所有子系统中该子项的物料，数据混淆

#### 修改后（数据隔离）

**场景1：查询特定子系统的物料**

```sql
SELECT * FROM erp_subsystem_material_template
WHERE item_template_id = ?
  AND template_id = ?  -- ✅ 增加此条件实现隔离
ORDER BY create_time DESC
```

**结果**：只返回当前子系统中的物料

**场景2：查询所有子系统的物料**

```sql
SELECT * FROM erp_subsystem_material_template
WHERE item_template_id = ?
ORDER BY create_time DESC
```

**结果**：返回所有子系统中的物料（向后兼容）

---

## 测试验证

### 测试场景

**准备数据**：
1. 创建子项模板：子项A（ID：1986239297161666561）
2. 创建子系统模板：子系统X（ID：1985928480973324290）
3. 创建子系统模板：子系统Y（ID：1985928480973324291）
4. 将子项A分别关联到子系统X和子系统Y

### 测试步骤1：查询数据隔离

**操作**：
1. 在子系统X中，查看子项A的物料列表
2. 在子系统Y中，查看子项A的物料列表

**预期结果**：
- ✅ 子系统X只显示自己的物料
- ✅ 子系统Y只显示自己的物料
- ✅ 两个列表互不干扰

**验证方法**：
```typescript
// 子系统X的查询
GET /erp/subsystem/material-template/list-by-item/1986239297161666561?templateId=1985928480973324290

// 子系统Y的查询
GET /erp/subsystem/material-template/list-by-item/1986239297161666561?templateId=1985928480973324291
```

---

### 测试步骤2：新增数据隔离

**操作**：
1. 在子系统X中，为子项A添加物料M1（铜鼻子，数量：10）
2. 在子系统Y中，为子项A添加物料M2（铜排，数量：20）

**预期结果**：
- ✅ 子系统X中只有物料M1
- ✅ 子系统Y中只有物料M2
- ✅ 两个子系统的物料记录独立存储

**验证数据**：
```sql
SELECT * FROM erp_subsystem_material_template 
WHERE item_template_id = 1986239297161666561;

-- 预期结果：
-- 记录1: template_id=1985928480973324290, material_id=M1, quantity=10
-- 记录2: template_id=1985928480973324291, material_id=M2, quantity=20
```

---

### 测试步骤3：修改数据隔离

**操作**：
1. 在子系统X中，将物料M1的数量修改为15
2. 查询子系统Y中的物料

**预期结果**：
- ✅ 子系统X中物料M1的数量变为15
- ✅ 子系统Y中的物料不受影响
- ✅ 修改操作完全隔离

---

### 测试步骤4：删除数据隔离

**操作**：
1. 在子系统X中，删除物料M1
2. 查询子系统Y中的物料

**预期结果**：
- ✅ 子系统X中物料M1被删除
- ✅ 子系统Y中的物料不受影响
- ✅ 删除操作完全隔离

---

## 修复效果

### 修复前的问题

1. ❌ 查询时不传递 `templateId`，查询到所有子系统的物料
2. ❌ 需要前端手动过滤数据，容易出错
3. ❌ 前端过滤不准确，可能导致数据混淆
4. ❌ 修改可能影响到其他子系统

### 修复后的效果

1. ✅ 查询时传递 `templateId`，后端直接过滤
2. ✅ 数据隔离在API层面实现，更加可靠
3. ✅ 前端代码更简洁，逻辑更清晰
4. ✅ 增删改操作完全独立，互不影响
5. ✅ 向后兼容，不破坏现有功能

---

## 关键代码对比

### 查询操作对比

#### 修改前
```typescript
// ❌ 没有传递 templateId
const response = await listMaterialTemplateByItemId(selectedItemId.value);

// ❌ 需要前端手动过滤
const allMaterials = response.data || [];
materialList.value = allMaterials.filter(
  material => Number(material.templateId) === Number(props.templateId)
);
```

#### 修改后
```typescript
// ✅ 传递 templateId，后端过滤
const response = await listMaterialTemplateByItemId(
  selectedItemId.value,
  props.templateId
);

// ✅ 直接使用返回数据
materialList.value = response.data || [];
```

---

## 注意事项

### 1. 使用场景区分

**子系统管理页面**：
- ✅ 必须传递 `templateId` 参数
- ✅ 实现数据隔离

**子项模板独立管理页面**：
- ✅ 不传递 `templateId` 参数
- ✅ 查询所有子系统中的物料

### 2. 新增物料时的注意事项

**关联到子系统**：
```typescript
{
  templateId: props.templateId,  // ✅ 必须设置
  itemTemplateId: selectedItemId.value,
  materialId: material.id,
  // ...
}
```

**独立子项模板**：
```typescript
{
  // ✅ 不设置 templateId（或设置为 undefined/null）
  itemTemplateId: materialDialog.itemId,
  materialId: material.id,
  // ...
}
```

### 3. 编辑物料时的注意事项

- ✅ 使用 `Object.assign` 复制所有字段，包括 `templateId`
- ✅ 不要手动修改 `templateId` 字段
- ✅ 更新操作不应该改变物料的归属关系

---

## 相关文档

- [子系统物料独立管理功能修复.md](./子系统物料独立管理功能修复.md)
- [子系统物料查询API使用指南.md](./子系统物料查询API使用指南.md)
- [子系统模板子项和物料管理API文档.md](./子系统模板子项和物料管理API文档.md)

---

## 修复记录

- **修复时间**：2025-11-06
- **修复人员**：AI助手
- **修复内容**：
  - 修改 `listMaterialTemplateByItemId` API接口，支持可选的 `templateId` 参数
  - 修改 `ItemTemplateManagement.vue` 组件的 `loadMaterialList` 方法，传递 `templateId` 实现数据隔离
  - 验证物料增删改操作的数据隔离实现
  - 创建修复文档和测试指南
- **影响范围**：
  - API接口：`src/api/erp/subsystem/material-template.ts`
  - 前端组件：`src/views/erp/subsystem/template/components/ItemTemplateManagement.vue`
- **向后兼容**：✅ 完全向后兼容
- **测试状态**：✅ 代码审查通过，待功能测试

