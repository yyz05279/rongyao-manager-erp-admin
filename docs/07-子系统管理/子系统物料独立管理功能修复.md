# 子系统物料独立管理功能修复

## 问题描述

用户反馈：**在子系统中修改子项的物料信息时，修改会影响到 `erp_subsystem_item_template` 表中的子项模板数据，而不是只修改当前子系统关联的物料数据。**

### 问题根因

当前的物料查询接口 `GET /erp/subsystem/material-template/list-by-item/{itemTemplateId}` 只根据 `itemTemplateId` 查询物料，没有考虑 `templateId`（子系统模板 ID）。

这导致：

1. 同一个子项模板被多个子系统使用时，查询到的是该子项模板在**所有子系统**中的物料记录
2. 无法区分不同子系统中同一子项的物料配置
3. 修改物料时可能影响到其他子系统的配置

## 数据模型说明

### 数据表结构

#### 1. `erp_subsystem_item_template` - 子项模板表

-   **用途**: 存储公司级别的、可复用的子项模板定义
-   **特点**: 独立于子系统，可被多个子系统关联使用
-   **主要字段**: `id`, `item_code`, `item_name`, `item_type`, `specification` 等

#### 2. `erp_subsystem_template_item_rel` - 子系统与子项关联表

-   **用途**: 记录子系统模板与子项模板的关联关系
-   **主要字段**: `id`, `template_id` (子系统模板 ID), `item_template_id` (子项模板 ID), `quantity`, `sequence_number`
-   **关键**: `id` 字段是关联关系的唯一标识，用于区分同一子项在不同子系统中的配置

#### 3. `erp_subsystem_material_template` - 物料模板表

-   **用途**: 存储物料配置，可以独立存在（独立模式）或与子系统关联（关联模式）
-   **主要字段**: `id`, `template_id`, `item_template_id`, `material_id`, `default_quantity`
-   **关键**: 通过 `template_id` 和 `item_template_id` 两个字段来区分不同子系统中同一子项的物料配置

### 数据关系

```
erp_subsystem_template (子系统模板)
    ↓ (1:N)
erp_subsystem_template_item_rel (关联关系)
    ↓ (N:1)
erp_subsystem_item_template (子项模板)
    ↓ (1:N)
erp_subsystem_material_template (物料模板)
```

### 物料数据存储规则

物料记录在 `erp_subsystem_material_template` 表中通过以下字段组合区分：

1. **独立子项模式**：

    - `template_id` = NULL
    - `item_template_id` = 子项模板 ID
    - 用途：独立子项模板的默认物料配置

2. **子系统关联模式**：
    - `template_id` = 子系统模板 ID
    - `item_template_id` = 子项模板 ID
    - 用途：特定子系统中该子项的物料配置（**独立管理，不影响其他子系统**）

## 用户需求分析

### 正确的业务逻辑

1. **独立性**: 被子系统关联后的子项，应该有独立的物料配置，只与当前子系统相关
2. **隔离性**: 对一个子系统中子项物料的增删改操作，不应该影响到：
    - 原始的子项模板（`erp_subsystem_item_template` 表）
    - 其他子系统中相同子项的物料配置
3. **唯一标识**: 通过 `template_id` + `item_template_id` 组合来唯一标识一个子系统中的子项物料配置

### 错误的实现

**当前实现**：

-   查询接口只根据 `itemTemplateId` 查询物料
-   查询到的是该子项在所有子系统中的物料（混合了多个子系统的数据）
-   前端看到的是多个子系统的物料混在一起

**问题示例**：

```
子系统 A (template_id=1) 关联了子项 X (item_template_id=10)
子系统 B (template_id=2) 关联了子项 X (item_template_id=10)

当前查询接口返回：
- 子项 X 在子系统 A 中的物料
- 子项 X 在子系统 B 中的物料
- 子项 X 的独立物料（template_id=NULL）

❌ 前端无法区分哪些物料属于当前子系统
```

## 解决方案

### 修改内容

#### 1. Controller 层修改

**文件**: `ErpSubsystemMaterialTemplateController.java`

```java
/**
 * 根据子项模板ID查询物料列表
 *
 * @param itemTemplateId 子项模板ID（必填）
 * @param templateId 子系统模板ID（可选，不传则查询该子项在所有子系统中的物料）
 */
@Operation(summary = "根据子项模板ID查询物料列表")
@SaCheckPermission("erp:subsystem:template:query")
@GetMapping("/list-by-item/{itemTemplateId}")
public R<List<ErpSubsystemMaterialTemplateVo>> listByItemTemplateId(
        @NotNull(message = "子项模板ID不能为空") @PathVariable Long itemTemplateId,
        @RequestParam(required = false) Long templateId) {
    return R.ok(materialTemplateService.queryListByItemTemplateId(itemTemplateId, templateId));
}
```

**变化**：

-   ✅ 增加了 `templateId` 查询参数（可选）
-   ✅ 使用 `@RequestParam(required = false)` 保证向后兼容

#### 2. Service 接口修改

**文件**: `IErpSubsystemMaterialTemplateService.java`

```java
/**
 * 根据子项模板ID查询物料列表
 *
 * @param itemTemplateId 子项模板ID
 * @param templateId 子系统模板ID（可选，不传则查询该子项在所有子系统中的物料）
 * @return 物料列表
 */
List<ErpSubsystemMaterialTemplateVo> queryListByItemTemplateId(Long itemTemplateId, Long templateId);
```

#### 3. Service 实现类修改

**文件**: `ErpSubsystemMaterialTemplateServiceImpl.java`

```java
@Override
public List<ErpSubsystemMaterialTemplateVo> queryListByItemTemplateId(Long itemTemplateId, Long templateId) {
    if (itemTemplateId == null) {
        return new ArrayList<>();
    }

    LambdaQueryWrapper<ErpSubsystemMaterialTemplate> lqw = Wrappers.lambdaQuery();
    lqw.eq(ErpSubsystemMaterialTemplate::getItemTemplateId, itemTemplateId);

    // ✅ 核心修改：如果提供了templateId，则只查询该子系统中该子项的物料（关联模式）
    // 如果没有提供templateId，则查询该子项在所有子系统中的物料（独立模式 + 关联模式）
    if (ObjectUtil.isNotEmpty(templateId)) {
        lqw.eq(ErpSubsystemMaterialTemplate::getTemplateId, templateId);
        log.debug("查询子项[{}]在子系统[{}]中的物料配置", itemTemplateId, templateId);
    } else {
        log.debug("查询子项[{}]在所有子系统中的物料配置", itemTemplateId);
    }

    lqw.orderByDesc(ErpSubsystemMaterialTemplate::getCreateTime);

    List<ErpSubsystemMaterialTemplate> list = baseMapper.selectList(lqw);
    return fillMaterialInfo(ErpSubsystemMaterialTemplateConvert.INSTANCE.toVo(list));
}
```

**关键改动**：

-   ✅ 增加了 `templateId` 参数
-   ✅ 当 `templateId` 不为空时，增加查询条件 `template_id = ?`
-   ✅ 添加了调试日志，方便排查问题

#### 4. 其他调用处修改

**文件**: `ErpSubsystemItemTemplateController.java`

```java
/**
 * 获取子项的物料列表（独立模式，查询所有子系统中该子项的物料）
 */
@Operation(summary = "获取子项的物料列表")
@SaCheckPermission("erp:subsystem:template:query")
@GetMapping("/{id}/materials")
public R<List<com.haitang.erp.domain.subsystem.vo.ErpSubsystemMaterialTemplateVo>> getItemMaterials(
        @NotNull(message = "子项ID不能为空") @PathVariable Long id) {
    // 不传templateId，查询该子项在所有子系统中的物料配置
    return R.ok(materialTemplateService.queryListByItemTemplateId(id, null));
}
```

**文件**: `ErpSubsystemTemplateItemRelServiceImpl.java`

```java
private void syncItemMaterialsToTemplate(Long templateId, Long itemTemplateId) {
    try {
        // 1. 查询子项模板的所有物料（不指定templateId，查询所有该子项的物料配置）
        // 注意：这里会查询该子项在所有子系统中的物料配置，用于初始化同步
        List<ErpSubsystemMaterialTemplateVo> itemMaterials = materialTemplateService
                .queryListByItemTemplateId(itemTemplateId, null);

        if (itemMaterials == null || itemMaterials.isEmpty()) {
            log.info("子项模板[{}]没有配置物料，跳过物料同步", itemTemplateId);
            return;
        }
        // ... 后续同步逻辑
    }
}
```

### API 调用变化

#### 修改前

```http
GET /erp/subsystem/material-template/list-by-item/123
```

查询结果：返回子项 123 在**所有子系统**中的物料（混合了多个子系统的数据）

#### 修改后

**场景 1：查询特定子系统中的子项物料**（推荐）

```http
GET /erp/subsystem/material-template/list-by-item/123?templateId=456
```

查询结果：只返回子项 123 在子系统 456 中的物料（隔离独立）

**场景 2：查询子项在所有子系统中的物料**（独立模式）

```http
GET /erp/subsystem/material-template/list-by-item/123
```

查询结果：返回子项 123 在所有子系统中的物料（向后兼容）

## 前端调用建议

### 当前问题

前端在查询子系统中子项的物料时，只传递了 `itemTemplateId`，没有传递 `templateId`：

```javascript
// ❌ 错误的调用方式
GET / erp / subsystem / material -
    template / list -
    by -
    item / 1986239297161666561;
```

### 正确的调用方式

**在子系统管理页面查询子项物料时，应该同时传递 `templateId`**：

```javascript
// ✅ 正确的调用方式
GET /erp/subsystem/material-template/list-by-item/1986239297161666561?templateId=1985928480973324290
```

### 代码示例

```javascript
// 查询子系统中子项的物料
async function getItemMaterials(itemTemplateId, templateId) {
    return request({
        url: `/erp/subsystem/material-template/list-by-item/${itemTemplateId}`,
        method: "get",
        params: {
            templateId: templateId, // ✅ 必须传递子系统模板ID
        },
    });
}

// 使用示例
const materials = await getItemMaterials(
    "1986239297161666561", // 子项ID
    "1985928480973324290" // 子系统ID
);
```

## 测试验证

### 测试场景 1：独立查询不同子系统的物料

**准备数据**：

1. 创建子项模板：子项 A（ID：100）
2. 创建子系统模板：子系统 X（ID：1），子系统 Y（ID：2）
3. 将子项 A 分别关联到子系统 X 和子系统 Y
4. 在子系统 X 中，为子项 A 添加物料：物料 M1（数量：10）
5. 在子系统 Y 中，为子项 A 添加物料：物料 M2（数量：20）

**测试步骤**：

1. 查询子项 A 在子系统 X 中的物料：

```http
GET /erp/subsystem/material-template/list-by-item/100?templateId=1
```

**预期结果**：

-   ✅ 只返回物料 M1（数量：10）
-   ✅ 不包含子系统 Y 的物料 M2

2. 查询子项 A 在子系统 Y 中的物料：

```http
GET /erp/subsystem/material-template/list-by-item/100?templateId=2
```

**预期结果**：

-   ✅ 只返回物料 M2（数量：20）
-   ✅ 不包含子系统 X 的物料 M1

3. 查询子项 A 在所有子系统中的物料：

```http
GET /erp/subsystem/material-template/list-by-item/100
```

**预期结果**：

-   ✅ 返回物料 M1 和 M2
-   ✅ 包含两个子系统的所有物料

### 测试场景 2：修改不影响其他子系统

**准备数据**：与场景 1 相同

**测试步骤**：

1. 在子系统 X 中，修改子项 A 的物料 M1 的数量为 15
2. 查询子系统 Y 中子项 A 的物料

**预期结果**：

-   ✅ 子系统 Y 中物料 M2 的数量仍然是 20
-   ✅ 修改没有影响到其他子系统

### 日志验证

启动服务后，查看日志：

```bash
tail -f /Users/yyz/Desktop/HaiTang-erp/logs/app.log | grep "查询子项"
```

**预期日志**：

```
查询子项[100]在子系统[1]中的物料配置
查询子项[100]在子系统[2]中的物料配置
查询子项[100]在所有子系统中的物料配置
```

## 数据隔离原理

### 查询条件对比

#### 修改前

```sql
SELECT * FROM erp_subsystem_material_template
WHERE item_template_id = ?
ORDER BY create_time DESC
```

**问题**: 没有 `template_id` 条件，查询到所有子系统的物料

#### 修改后

**场景 1：查询特定子系统**

```sql
SELECT * FROM erp_subsystem_material_template
WHERE item_template_id = ?
  AND template_id = ?  -- ✅ 增加了这个条件
ORDER BY create_time DESC
```

**场景 2：查询所有子系统**（不传 templateId）

```sql
SELECT * FROM erp_subsystem_material_template
WHERE item_template_id = ?
ORDER BY create_time DESC
```

### 数据隔离示例

假设数据库中的记录：

| id  | template_id | item_template_id | material_id | default_quantity |
| --- | ----------- | ---------------- | ----------- | ---------------- |
| 1   | 1           | 100              | 200         | 10               |
| 2   | 1           | 100              | 201         | 5                |
| 3   | 2           | 100              | 200         | 20               |
| 4   | 2           | 100              | 202         | 15               |
| 5   | NULL        | 100              | 203         | 1                |

#### 查询 1：子项 100 在子系统 1 中的物料

```sql
WHERE item_template_id = 100 AND template_id = 1
```

**结果**: 返回 id=1, id=2 （2 条记录）

#### 查询 2：子项 100 在子系统 2 中的物料

```sql
WHERE item_template_id = 100 AND template_id = 2
```

**结果**: 返回 id=3, id=4 （2 条记录）

#### 查询 3：子项 100 在所有子系统中的物料

```sql
WHERE item_template_id = 100
```

**结果**: 返回 id=1, 2, 3, 4, 5 （5 条记录，包含独立物料）

## 修复总结

### 核心改动

1. **Controller 层**: 增加 `templateId` 查询参数
2. **Service 层**: 修改查询条件，支持通过 `template_id` 过滤
3. **数据隔离**: 实现不同子系统中同一子项的物料配置独立管理

### 关键原理

-   通过 `template_id` + `item_template_id` 组合来唯一标识一个子系统中的子项物料配置
-   修改查询条件，增加 `template_id` 过滤，实现数据隔离
-   保持向后兼容，不传 `templateId` 时查询所有物料

### 业务价值

1. **数据隔离**: 不同子系统中同一子项的物料配置完全独立，互不影响
2. **管理灵活**: 同一子项在不同子系统中可以有不同的物料配置
3. **安全可控**: 修改一个子系统的物料不会影响其他子系统

---

## 修复记录

-   **修复时间**: 2025-11-06
-   **修复内容**:
    -   修改 `ErpSubsystemMaterialTemplateController.listByItemTemplateId()` 方法，增加 `templateId` 参数
    -   修改 `IErpSubsystemMaterialTemplateService.queryListByItemTemplateId()` 接口签名
    -   修改 `ErpSubsystemMaterialTemplateServiceImpl.queryListByItemTemplateId()` 实现，增加 `template_id` 查询条件
    -   更新所有调用处，传递正确的参数
-   **影响范围**:
    -   子系统物料查询接口
    -   前端调用方式（需要传递 `templateId` 参数）
-   **向后兼容**: ✅ 完全向后兼容（`templateId` 参数为可选）
